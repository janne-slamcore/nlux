{"version":3,"file":"markdown.js","sources":["../../../../packages/shared/src/utils/warn.ts","../../../../packages/shared/src/markdown/copyToClipboard/attachCopyClickListener.ts","../../../../packages/shared/src/utils/dom/emptyInnerHtml.ts","../../../../packages/shared/src/markdown/copyToClipboard/insertCopyToClipboardButton.ts","../../../../packages/shared/src/markdown/snapshot/marked/defaults.ts","../../../../packages/shared/src/markdown/snapshot/marked/Hooks.ts","../../../../packages/shared/src/markdown/snapshot/marked/helpers.ts","../../../../packages/shared/src/markdown/snapshot/marked/rules.ts","../../../../packages/shared/src/markdown/snapshot/marked/Tokenizer.ts","../../../../packages/shared/src/markdown/snapshot/marked/Lexer.ts","../../../../packages/shared/src/markdown/snapshot/marked/Renderer.ts","../../../../packages/shared/src/markdown/snapshot/marked/TextRenderer.ts","../../../../packages/shared/src/markdown/snapshot/marked/Parser.ts","../../../../packages/shared/src/markdown/snapshot/marked/Instance.ts","../../../../packages/shared/src/markdown/snapshot/marked/marked.ts","../../../../packages/shared/src/markdown/snapshot/snapshotParser.ts","../../../../packages/shared/src/markdown/stream/streamParser.ts","../../../../packages/extra/markdown/src/index.ts"],"sourcesContent":["export const warn = (message: unknown) => {\n    if (typeof message === 'string') {\n        console.warn(`[nlux] ${message}`);\n        return;\n    }\n\n    if (message && typeof message.toString === 'function') {\n        console.warn(`[nlux] ${message.toString()}`);\n        return;\n    }\n\n    console.warn('[nlux]');\n    console.log(JSON.stringify(message, null, 2));\n};\n\nconst warnedMessages: string[] = [];\nexport const warnOnce = (message: string) => {\n    if (warnedMessages.includes(message)) {\n        return;\n    }\n\n    warnedMessages.push(message);\n    warn(message);\n};\n","const addListenersToCopyButton = (copyButton: Element) => {\n    if (!(copyButton instanceof HTMLButtonElement)) {\n        return;\n    }\n\n    // If button has click event listener, do not add another one\n    if (copyButton.dataset.clickListenerSet === 'true') {\n        return;\n    }\n\n    let clicked = false;\n    const codeBlock = copyButton.nextElementSibling as HTMLElement;\n    copyButton.addEventListener('click', () => {\n        if (clicked || !codeBlock) {\n            return;\n        }\n\n        // Copy code to clipboard\n        const code = codeBlock.innerText;\n        navigator.clipboard.writeText(code ?? '');\n\n        // Mark button as clicked for 1 second\n        clicked = true;\n        copyButton.classList.add('clicked');\n        setTimeout(() => {\n            clicked = false;\n            copyButton.classList.remove('clicked');\n        }, 1000);\n    });\n\n    // Set data attribute to indicate that click event listener has been set\n    copyButton.dataset.clickListenerSet = 'true';\n};\n\nexport const attachCopyClickListener = (markdownContainer: HTMLElement) => {\n    const copyButtonCssClass = 'nlux-comp-copyButton';\n    if (\n        markdownContainer instanceof HTMLButtonElement &&\n        markdownContainer.classList.contains(copyButtonCssClass)\n    ) {\n        addListenersToCopyButton(markdownContainer);\n        return;\n    }\n\n    markdownContainer.querySelectorAll(`.${copyButtonCssClass}`).forEach(addListenersToCopyButton);\n};\n","export const emptyInnerHtml = (element: HTMLElement): void => {\n    element.replaceChildren();\n};\n","export const insertCopyToClipboardButton = (markdownContainer: HTMLElement) => {\n    markdownContainer.querySelectorAll('.code-block').forEach((codeBlockContainer) => {\n        const codeBlock = codeBlockContainer.querySelector('pre');\n        if (!codeBlock) {\n            return;\n        }\n\n        // Check the adjacent element to see if a copy button is already present\n        if (codeBlockContainer.previousElementSibling?.classList.contains('nlux-comp-copyButton')) {\n            return;\n        }\n\n        const title = 'Copy code block to clipboard';\n        const copyButton = document.createElement('button');\n\n        copyButton.classList.add('nlux-comp-copyButton');\n        copyButton.setAttribute('aria-label', title);\n        copyButton.setAttribute('title', title);\n\n        const copyIcon = document.createElement('span');\n        copyIcon.classList.add('icon-copy');\n        copyButton.appendChild(copyIcon);\n\n        codeBlockContainer.appendChild(copyButton);\n    });\n};\n","import type {MarkedOptions} from './MarkedOptions';\n\n/**\n * Gets the original marked default options.\n */\nexport function _getDefaults(): MarkedOptions {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\n\nexport let _defaults = _getDefaults();\n\nexport function changeDefaults(newDefaults: MarkedOptions) {\n    _defaults = newDefaults;\n}\n","import {_defaults} from './defaults';\nimport type {MarkedOptions} from './MarkedOptions';\nimport type {Token, TokensList} from './Tokens';\n\nexport class _Hooks {\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    options: MarkedOptions;\n\n    constructor(options?: MarkedOptions) {\n        this.options = options || _defaults;\n    }\n\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html: string) {\n        return html;\n    }\n\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown: string) {\n        return markdown;\n    }\n\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens: Token[] | TokensList) {\n        return tokens;\n    }\n}\n","/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements: {[index: string]: string} = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n};\nconst getEscapeReplacement = (ch: string) => escapeReplacements[ch];\n\nexport function escape(html: string, encode?: boolean) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n\n    return html;\n}\n\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\nexport function unescape(html: string) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n) => {\n        n = n.toLowerCase();\n        if (n === 'colon') {\n            return ':';\n        }\n        if (n.charAt(0) === '#') {\n            return n.charAt(1) === 'x'\n                ? String.fromCharCode(parseInt(n.substring(2), 16))\n                : String.fromCharCode(+n.substring(1));\n        }\n        return '';\n    });\n}\n\nconst caret = /(^|[^\\[])\\^/g;\n\nexport function edit(regex: string | RegExp, opt?: string) {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    opt = opt || '';\n    const obj = {\n        replace: (name: string | RegExp, val: string | RegExp) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\n\nexport function cleanUrl(href: string) {\n    try {\n        href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\n\nexport const noopTest = {exec: () => null} as unknown as RegExp;\n\nexport function splitCells(tableRow: string, count?: number) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n            let escaped = false;\n            let curr = offset;\n            while (--curr >= 0 && str[curr] === '\\\\') {\n                escaped = !escaped;\n            }\n            if (escaped) {\n                // odd number of slashes means | is escaped\n                // so we leave it alone\n                return '|';\n            } else {\n                // add space before unescaped |\n                return ' |';\n            }\n        }),\n        cells = row.split(/ \\|/);\n    let i = 0;\n\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while (cells.length < count) {\n                cells.push('');\n            }\n        }\n    }\n\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n    return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str: string, c: string, invert?: boolean) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else {\n            if (currChar !== c && invert) {\n                suffLen++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return str.slice(0, l - suffLen);\n}\n\nexport function findClosingBracket(str: string, b: string) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        } else {\n            if (str[i] === b[0]) {\n                level++;\n            } else {\n                if (str[i] === b[1]) {\n                    level--;\n                    if (level < 0) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n","import {edit, noopTest} from './helpers';\n\n/**\n * Block-Level Grammar\n */\n\nconst newline = /^(?: *(?:\\n|$))+/;\nconst blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(\n    /^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\n\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\n\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\n    '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7)\n    // closing\n    // tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\n\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\n\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n\ntype BlockKeys = keyof typeof blockNormal;\n\n/**\n * GFM Block Grammar\n */\n\nconst gfmTable = edit(\n    '^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', ' {4}[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\n\nconst blockGfm: Record<BlockKeys, RegExp> = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nconst blockPedantic: Record<BlockKeys, RegExp> = {\n    ...blockNormal,\n    html: edit(\n        '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n            + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n            + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n            + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n\n/**\n * Inline-Level Grammar\n */\n\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = '\\\\p{P}\\\\p{S}';\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n    .replace(/punctuation/g, _punctuation).getRegex();\n\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n\nconst emStrongRDelimAst = edit(\n    '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\n    '^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n\nconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email',\n        /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,\n    )\n    .getRegex();\n\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit(\n    '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\n\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\n\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\n\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\n\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n\ntype InlineKeys = keyof typeof inlineNormal;\n\n/**\n * Pedantic Inline Grammar\n */\n\nconst inlinePedantic: Record<InlineKeys, RegExp> = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n\n/**\n * GFM Inline Grammar\n */\n\nconst inlineGfm: Record<InlineKeys, RegExp> = {\n    ...inlineNormal,\n    escape: edit(escape).replace('])', '~|])').getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\nconst inlineBreaks: Record<InlineKeys, RegExp> = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n\n/**\n * exports\n */\n\nexport const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\n\nexport const inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n\nexport interface Rules {\n    block: Record<BlockKeys, RegExp>;\n    inline: Record<InlineKeys, RegExp>;\n}\n","import {_defaults} from './defaults';\nimport {escape, findClosingBracket, rtrim, splitCells} from './helpers';\nimport type {_Lexer} from './Lexer';\nimport type {MarkedOptions} from './MarkedOptions';\nimport type {Rules} from './rules';\nimport type {Links, Tokens} from './Tokens';\n\nfunction outputLink(cap: string[], link: Pick<Tokens.Link, 'href' | 'title'>, raw: string, lexer: _Lexer): Tokens.Link | Tokens.Image {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token: Tokens.Link = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text: escape(text),\n    };\n}\n\nfunction indentCodeCompensation(raw: string, text: string) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n        return text;\n    }\n\n    const indentToCode = matchIndentToCode[1];\n\n    return text\n        .split('\\n')\n        .map(node => {\n            const matchIndentInNode = node.match(/^\\s+/);\n            if (matchIndentInNode === null) {\n                return node;\n            }\n\n            const [indentInNode] = matchIndentInNode;\n\n            if (indentInNode.length >= indentToCode.length) {\n                return node.slice(indentToCode.length);\n            }\n\n            return node;\n        })\n        .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nexport class _Tokenizer {\n    lexer!: _Lexer; // set by the lexer\n    options: MarkedOptions;\n    rules!: Rules; // set by the lexer\n\n    constructor(options?: MarkedOptions) {\n        this.options = options || _defaults;\n    }\n\n    autolink(src: string): Tokens.Link | undefined {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[1]);\n                href = 'mailto:' + text;\n            } else {\n                text = escape(cap[1]);\n                href = text;\n            }\n\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n\n    blockquote(src: string): Tokens.Blockquote | undefined {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            // precede setext continuation with 4 spaces so it isn't a setext\n            let text = cap[0].replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1');\n            text = rtrim(text.replace(/^ *>[ \\t]?/gm, ''), '\\n');\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: 'blockquote',\n                raw: cap[0],\n                tokens,\n                text,\n            };\n        }\n    }\n\n    br(src: string): Tokens.Br | undefined {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n\n    code(src: string): Tokens.Code | undefined {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n\n    codespan(src: string): Tokens.Codespan | undefined {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, ' ');\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n\n    def(src: string): Tokens.Def | undefined {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation,\n                '$1',\n            ) : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n\n    del(src: string): Tokens.Del | undefined {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n\n    emStrong(src: string, maskedSrc: string, prevChar = ''): Tokens.Em | Tokens.Strong | undefined {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match) {\n            return;\n        }\n\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) {\n            return;\n        }\n\n        const nextChar = match[1] || match[2] || '';\n\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...(match as any)[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n            const endReg = match[0][0] === '*'\n                ? this.rules.inline.emStrongRDelimAst\n                : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n                if (!rDelim) {\n                    continue;\n                } // skip single * in __abc*abc__\n\n                rLength = [...rDelim].length;\n\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                } else {\n                    if (match[5] || match[6]) { // either Left or Right Delim\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                }\n\n                delimTotal -= rLength;\n\n                if (delimTotal > 0) {\n                    continue;\n                } // Haven't found enough closing delimiters\n\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...(match as any)[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n\n    escape(src: string): Tokens.Escape | undefined {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: escape(cap[1]),\n            };\n        }\n    }\n\n    fences(src: string): Tokens.Code | undefined {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '');\n\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n\n    heading(src: string): Tokens.Heading | undefined {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else {\n                    if (!trimmed || / $/.test(trimmed)) {\n                        // CommonMark requires space before trailing #s\n                        text = trimmed.trim();\n                    }\n                }\n            }\n\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n\n    hr(src: string): Tokens.Hr | undefined {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: cap[0],\n            };\n        }\n    }\n\n    html(src: string): Tokens.HTML | undefined {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token: Tokens.HTML = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n\n    inlineText(src: string): Tokens.Text | undefined {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            } else {\n                text = escape(cap[0]);\n            }\n            return {\n                type: 'text',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n\n    lheading(src: string): Tokens.Heading | undefined {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n\n    link(src: string): Tokens.Link | Tokens.Image | undefined {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(/>$/.test(trimmedUrl))) {\n                    return;\n                }\n\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer);\n        }\n    }\n\n    list(src: string): Tokens.List | undefined {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n\n            const list: Tokens.List = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let raw = '';\n            let itemContents = '';\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n\n                raw = cap[0];\n                src = src.substring(raw.length);\n\n                let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t: string) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n\n                let blankLine = false;\n\n                if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(\n                        `^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(\n                        `^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        nextLine = rawLine;\n\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                        }\n\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n\n                            itemContents += '\\n' + nextLine;\n                        }\n\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else {\n                        if (/\\n *\\n *$/.test(raw)) {\n                            endsWithBlankLine = true;\n                        }\n                    }\n                }\n\n                let istask: RegExpExecArray | null = null;\n                let ischecked: boolean | undefined;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                    }\n                }\n\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n\n                list.raw += raw;\n            }\n\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to\n            // simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimEnd();\n            (list.items[list.items.length - 1]).text = itemContents.trimEnd();\n            list.raw = list.raw.trimEnd();\n\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n\n            return list;\n        }\n    }\n\n    paragraph(src: string): Tokens.Paragraph | undefined {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n\n    reflink(src: string, links: Links): Tokens.Link | Tokens.Image | Tokens.Text | undefined {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n\n    space(src: string): Tokens.Space | undefined {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n\n    table(src: string): Tokens.Table | undefined {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n\n        const item: Tokens.Table = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n\n        for (const align of aligns) {\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push('right');\n            } else {\n                if (/^ *:-+: *$/.test(align)) {\n                    item.align.push('center');\n                } else {\n                    if (/^ *:-+ *$/.test(align)) {\n                        item.align.push('left');\n                    } else {\n                        item.align.push(null);\n                    }\n                }\n            }\n        }\n\n        for (const header of headers) {\n            item.header.push({\n                text: header,\n                tokens: this.lexer.inline(header),\n            });\n        }\n\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map(cell => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                };\n            }));\n        }\n\n        return item;\n    }\n\n    tag(src: string): Tokens.Tag | undefined {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else {\n                if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                    this.lexer.state.inLink = false;\n                }\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else {\n                if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                    this.lexer.state.inRawBlock = false;\n                }\n            }\n\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n\n    text(src: string): Tokens.Text | undefined {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n\n    url(src: string): Tokens.Link | undefined {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[0]);\n                href = 'mailto:' + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                }\n                while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n}\n","import {_defaults} from './defaults';\nimport type {MarkedOptions, TokenizerExtension} from './MarkedOptions';\nimport {block, inline} from './rules';\nimport {_Tokenizer} from './Tokenizer';\nimport type {Token, Tokens, TokensList} from './Tokens';\n\n/**\n * Block Lexer\n */\nexport class _Lexer {\n    options: MarkedOptions;\n    state: {\n        inLink: boolean;\n        inRawBlock: boolean;\n        top: boolean;\n    };\n    tokens: TokensList;\n    private inlineQueue: {src: string, tokens: Token[]}[];\n    private tokenizer: _Tokenizer;\n\n    constructor(options?: MarkedOptions) {\n        // TokenList cannot be created in one go\n        this.tokens = [] as unknown as TokensList;\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n\n        const rules = {\n            block: block.normal,\n            inline: inline.normal,\n        };\n\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else {\n            if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) {\n                    rules.inline = inline.breaks;\n                } else {\n                    rules.inline = inline.gfm;\n                }\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n\n    /**\n     * Static Lex Method\n     */\n    static lex(src: string, options?: MarkedOptions) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src: string, options?: MarkedOptions) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n\n    /**\n     * Lexing\n     */\n    blockTokens(src: string, tokens?: Token[]): Token[];\n\n    blockTokens(src: string, tokens?: TokensList): TokensList;\n\n    blockTokens(src: string, tokens: Token[] = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n                return leading + '    '.repeat(tabs.length);\n            });\n        }\n\n        let token: Tokens.Generic | undefined;\n        let lastToken;\n        let cutSrc;\n        let lastParagraphClipped;\n\n        while (src) {\n            if (this.options.extensions\n                && this.options.extensions.block\n                && this.options.extensions.block.some((extTokenizer: TokenizerExtension['tokenizer']) => {\n                    if (token = extTokenizer.call({lexer: this}, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += '\\n';\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    if (!this.tokens.links[token.tag]) {\n                        this.tokens.links[token.tag] = {\n                            href: token.href,\n                            title: token.title,\n                        };\n                    }\n                }\n                continue;\n            }\n\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({lexer: this}, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = (cutSrc.length !== src.length);\n                src = src.substring(token.raw.length);\n                continue;\n            }\n\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n\n        this.state.top = true;\n        return tokens;\n    }\n\n    inline(src: string, tokens: Token[] = []) {\n        this.inlineQueue.push({src, tokens});\n        return tokens;\n    }\n\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src: string, tokens: Token[] = []): Token[] {\n        let token, lastToken, cutSrc;\n\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']'\n                            + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(\n                this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(\n                this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n\n            // extensions\n            if (this.options.extensions\n                && this.options.extensions.inline\n                && this.options.extensions.inline.some((extTokenizer) => {\n                    if (token = extTokenizer.call({lexer: this}, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({lexer: this}, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Preprocessing\n     */\n    lex(src: string) {\n        src = src\n            .replace(/\\r\\n|\\r/g, '\\n');\n\n        this.blockTokens(src, this.tokens);\n\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n\n        return this.tokens;\n    }\n}\n","import {_defaults} from './defaults';\nimport {cleanUrl, escape} from './helpers';\nimport type {MarkedOptions} from './MarkedOptions';\n\n/**\n * Renderer\n */\nexport class _Renderer {\n    options: MarkedOptions;\n\n    constructor(options?: MarkedOptions) {\n        this.options = options || _defaults;\n    }\n\n    blockquote(quote: string): string {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n\n    br(): string {\n        return '<br>';\n    }\n\n    checkbox(checked: boolean): string {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n\n    code(code: string, infostring: string | undefined, escaped: boolean): string {\n        const lang = (infostring || '').match(/^\\S*/)?.[0];\n\n        code = code.replace(/\\n$/, '') + '\\n';\n\n        if (!lang) {\n            return '<pre><code>'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n\n        return '<pre><code class=\"language-'\n            + escape(lang)\n            + '\">'\n            + (escaped ? code : escape(code, true))\n            + '</code></pre>\\n';\n    }\n\n    codespan(text: string): string {\n        return `<code>${text}</code>`;\n    }\n\n    del(text: string): string {\n        return `<del>${text}</del>`;\n    }\n\n    em(text: string): string {\n        return `<em>${text}</em>`;\n    }\n\n    heading(text: string, level: number, raw: string): string {\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n\n    hr(): string {\n        return '<hr>\\n';\n    }\n\n    html(html: string, block?: boolean): string {\n        return html;\n    }\n\n    image(href: string, title: string | null, text: string): string {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += '>';\n        return out;\n    }\n\n    link(href: string, title: string | null | undefined, text: string): string {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n\n    list(body: string, ordered: boolean, start: number | ''): string {\n        const type = ordered ? 'ol' : 'ul';\n        const startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    }\n\n    listitem(text: string, task: boolean, checked: boolean): string {\n        return `<li>${text}</li>\\n`;\n    }\n\n    paragraph(text: string): string {\n        return `<p>${text}</p>\\n`;\n    }\n\n    /**\n     * span level renderer\n     */\n    strong(text: string): string {\n        return `<strong>${text}</strong>`;\n    }\n\n    table(header: string, body: string): string {\n        if (body) {\n            body = `<tbody>${body}</tbody>`;\n        }\n\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n\n    tablecell(content: string, flags: {\n        header: boolean;\n        align: 'center' | 'left' | 'right' | null;\n    }): string {\n        const type = flags.header ? 'th' : 'td';\n        const tag = flags.align\n            ? `<${type} align=\"${flags.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n\n    tablerow(content: string): string {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n\n    text(text: string): string {\n        return text;\n    }\n}\n","/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer {\n    br() {\n        return '';\n    }\n\n    codespan(text: string) {\n        return text;\n    }\n\n    del(text: string) {\n        return text;\n    }\n\n    em(text: string) {\n        return text;\n    }\n\n    html(text: string) {\n        return text;\n    }\n\n    image(href: string, title: string | null, text: string) {\n        return '' + text;\n    }\n\n    link(href: string, title: string | null | undefined, text: string) {\n        return '' + text;\n    }\n\n    // no need for block level renderers\n    strong(text: string) {\n        return text;\n    }\n\n    text(text: string) {\n        return text;\n    }\n}\n","import {_defaults} from './defaults';\nimport {unescape} from './helpers';\nimport type {MarkedOptions} from './MarkedOptions';\nimport {_Renderer} from './Renderer';\nimport {_TextRenderer} from './TextRenderer';\nimport type {Token, Tokens} from './Tokens';\n\n/**\n * Parsing & Compiling\n */\nexport class _Parser {\n    options: MarkedOptions;\n    renderer: _Renderer;\n    textRenderer: _TextRenderer;\n\n    constructor(options?: MarkedOptions) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new _TextRenderer();\n    }\n\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens: Token[], options?: MarkedOptions) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens: Token[], options?: MarkedOptions) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n\n    /**\n     * Parse Loop\n     */\n    parse(tokens: Token[], top = true): string {\n        let out = '';\n\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers\n                && this.options.extensions.renderers[token.type]) {\n                const genericToken = token as Tokens.Generic;\n                const ret = this.options.extensions.renderers[genericToken.type].call({parser: this}, genericToken);\n                if (ret !== false || ![\n                    'space',\n                    'hr',\n                    'heading',\n                    'code',\n                    'table',\n                    'blockquote',\n                    'list',\n                    'html',\n                    'paragraph',\n                    'text',\n                ].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n\n            switch (token.type) {\n                case 'space': {\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr();\n                    continue;\n                }\n                case 'heading': {\n                    const headingToken = token as Tokens.Heading;\n                    out += this.renderer.heading(\n                        this.parseInline(headingToken.tokens),\n                        headingToken.depth,\n                        unescape(this.parseInline(headingToken.tokens, this.textRenderer)),\n                    );\n                    continue;\n                }\n                case 'code': {\n                    const codeToken = token as Tokens.Code;\n                    out += this.renderer.code(codeToken.text,\n                        codeToken.lang,\n                        !!codeToken.escaped,\n                    );\n                    continue;\n                }\n                case 'table': {\n                    const tableToken = token as Tokens.Table;\n                    let header = '';\n\n                    // header\n                    let cell = '';\n                    for (let j = 0; j < tableToken.header.length; j++) {\n                        cell += this.renderer.tablecell(\n                            this.parseInline(tableToken.header[j].tokens),\n                            {header: true, align: tableToken.align[j]},\n                        );\n                    }\n                    header += this.renderer.tablerow(cell);\n\n                    let body = '';\n                    for (let j = 0; j < tableToken.rows.length; j++) {\n                        const row = tableToken.rows[j];\n\n                        cell = '';\n                        for (let k = 0; k < row.length; k++) {\n                            cell += this.renderer.tablecell(\n                                this.parseInline(row[k].tokens),\n                                {header: false, align: tableToken.align[k]},\n                            );\n                        }\n\n                        body += this.renderer.tablerow(cell);\n                    }\n                    out += this.renderer.table(header, body);\n                    continue;\n                }\n                case 'blockquote': {\n                    const blockquoteToken = token as Tokens.Blockquote;\n                    const body = this.parse(blockquoteToken.tokens);\n                    out += this.renderer.blockquote(body);\n                    continue;\n                }\n                case 'list': {\n                    const listToken = token as Tokens.List;\n                    const ordered = listToken.ordered;\n                    const start = listToken.start;\n                    const loose = listToken.loose;\n\n                    let body = '';\n                    for (let j = 0; j < listToken.items.length; j++) {\n                        const item = listToken.items[j];\n                        const checked = item.checked;\n                        const task = item.task;\n\n                        let itemBody = '';\n                        if (item.task) {\n                            const checkbox = this.renderer.checkbox(!!checked);\n                            if (loose) {\n                                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0\n                                        && item.tokens[0].tokens[0].type === 'text') {\n                                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                                    }\n                                } else {\n                                    item.tokens.unshift({\n                                        type: 'text',\n                                        text: checkbox + ' ',\n                                    } as Tokens.Text);\n                                }\n                            } else {\n                                itemBody += checkbox + ' ';\n                            }\n                        }\n\n                        itemBody += this.parse(item.tokens, loose);\n                        body += this.renderer.listitem(itemBody, task, !!checked);\n                    }\n\n                    out += this.renderer.list(body, ordered, start);\n                    continue;\n                }\n                case 'html': {\n                    const htmlToken = token as Tokens.HTML;\n                    out += this.renderer.html(htmlToken.text, htmlToken.block);\n                    continue;\n                }\n                case 'paragraph': {\n                    const paragraphToken = token as Tokens.Paragraph;\n                    out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token as Tokens.Text;\n                    let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i] as Tokens.Text;\n                        body += '\\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                    }\n                    out += top ? this.renderer.paragraph(body) : body;\n                    continue;\n                }\n\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    } else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens: Token[], renderer?: _Renderer | _TextRenderer): string {\n        renderer = renderer || this.renderer;\n        let out = '';\n\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers\n                && this.options.extensions.renderers[token.type]) {\n                const ret = this.options.extensions.renderers[token.type].call({parser: this}, token);\n                if (ret !== false || ![\n                    'escape',\n                    'html',\n                    'link',\n                    'image',\n                    'strong',\n                    'em',\n                    'codespan',\n                    'br',\n                    'del',\n                    'text',\n                ].includes(token.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n\n            switch (token.type) {\n                case 'escape': {\n                    const escapeToken = token as Tokens.Escape;\n                    out += renderer.text(escapeToken.text);\n                    break;\n                }\n                case 'html': {\n                    const tagToken = token as Tokens.Tag;\n                    out += renderer.html(tagToken.text);\n                    break;\n                }\n                case 'link': {\n                    const linkToken = token as Tokens.Link;\n                    out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                    break;\n                }\n                case 'image': {\n                    const imageToken = token as Tokens.Image;\n                    out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                    break;\n                }\n                case 'strong': {\n                    const strongToken = token as Tokens.Strong;\n                    out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                    break;\n                }\n                case 'em': {\n                    const emToken = token as Tokens.Em;\n                    out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                    break;\n                }\n                case 'codespan': {\n                    const codespanToken = token as Tokens.Codespan;\n                    out += renderer.codespan(codespanToken.text);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br();\n                    break;\n                }\n                case 'del': {\n                    const delToken = token as Tokens.Del;\n                    out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                    break;\n                }\n                case 'text': {\n                    const textToken = token as Tokens.Text;\n                    out += renderer.text(textToken.text);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    } else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n","import {_getDefaults} from './defaults';\nimport {escape} from './helpers';\nimport {_Hooks} from './Hooks';\nimport {_Lexer} from './Lexer';\nimport type {MarkedExtension, MarkedOptions} from './MarkedOptions';\nimport {_Parser} from './Parser';\nimport {_Renderer} from './Renderer';\nimport {_TextRenderer} from './TextRenderer';\nimport {_Tokenizer} from './Tokenizer';\nimport type {Token, Tokens, TokensList} from './Tokens';\n\nexport type MaybePromise = void | Promise<void>;\n\ntype UnknownFunction = (...args: unknown[]) => unknown;\ntype GenericRendererFunction = (...args: unknown[]) => string | false;\n\nexport class Marked {\n    Hooks = _Hooks;\n    Lexer = _Lexer;\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Tokenizer = _Tokenizer;\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n    parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n\n    constructor(...args: MarkedExtension[]) {\n        this.use(...args);\n    }\n\n    lexer(src: string, options?: MarkedOptions) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n\n    parser(tokens: Token[], options?: MarkedOptions) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n\n    setOptions(opt: MarkedOptions) {\n        this.defaults = {...this.defaults, ...opt};\n        return this;\n    }\n\n    use(...args: MarkedExtension[]) {\n        const extensions: MarkedOptions['extensions'] = this.defaults.extensions || {renderers: {}, childTokens: {}};\n\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = {...pack} as unknown as MarkedOptions;\n\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error('extension level must be \\'block\\' or \\'inline\\'');\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            } else {\n                                if (ext.level === 'inline') {\n                                    if (extensions.startInline) {\n                                        extensions.startInline.push(ext.start);\n                                    } else {\n                                        extensions.startInline = [ext.start];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (prop === 'options') {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop as Exclude<keyof _Renderer, 'options'>;\n                    const rendererFunc = pack.renderer[rendererProp] as GenericRendererFunction;\n                    const prevRenderer = renderer[rendererProp] as GenericRendererFunction;\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args: unknown[]) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop as Exclude<keyof _Tokenizer, 'options' | 'rules' | 'lexer'>;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp] as UnknownFunction;\n                    const prevTokenizer = tokenizer[tokenizerProp] as UnknownFunction;\n\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-ignore\n                    tokenizer[tokenizerProp] = (...args: unknown[]) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (prop === 'options') {\n                        // ignore options property\n                        continue;\n                    }\n                    const hooksProp = prop as Exclude<keyof _Hooks, 'options'>;\n                    const hooksFunc = pack.hooks[hooksProp] as UnknownFunction;\n                    const prevHook = hooks[hooksProp] as UnknownFunction;\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-ignore\n                        hooks[hooksProp] = (arg: unknown) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        // @ts-ignore\n                        hooks[hooksProp] = (...args: unknown[]) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values: MaybePromise[] = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n\n            this.defaults = {...this.defaults, ...opts};\n        });\n\n        return this;\n    }\n\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n        let values: MaybePromise[] = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token as Tokens.Table;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token as Tokens.List;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token as Tokens.Generic;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity) as Token[] | TokensList;\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    } else {\n                        if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n                }\n            }\n        }\n        return values;\n    }\n\n    // @ts-ignore\n    #onError(silent: boolean, async: boolean) {\n        return (e: Error): string | Promise<string> => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n\n    // @ts-ignore\n    #parseMarkdown(lexer: (src: string, options?: MarkedOptions) => TokensList | Token[], parser: (tokens: Token[], options?: MarkedOptions) => string) {\n        return (src: string, options?: MarkedOptions | undefined | null): string | Promise<string> => {\n            const origOpt = {...options};\n            const opt = {...this.defaults, ...origOpt};\n\n            // Show warning if an extension set async to true but the parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                if (!opt.silent) {\n                    console.warn(\n                        'marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');\n                }\n\n                opt.async = true;\n            }\n\n            const throwError = this.#onError(!!opt.silent, !!opt.async);\n\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                              .then(src => lexer(src, opt))\n                              .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                              .then(\n                                  tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(\n                                      () => tokens) : tokens)\n                              .then(tokens => parser(tokens, opt))\n                              .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                              .catch(throwError);\n            }\n\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src) as string;\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens) as Token[] | TokensList;\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html) as string;\n                }\n                return html;\n            } catch (e) {\n                return throwError(e as Error);\n            }\n        };\n    }\n}\n","import {_defaults, _getDefaults, changeDefaults} from './defaults';\nimport {_Hooks} from './Hooks';\nimport type {MaybePromise} from './Instance';\nimport {Marked} from './Instance';\nimport {_Lexer} from './Lexer';\nimport type {MarkedExtension, MarkedOptions} from './MarkedOptions';\nimport {_Parser} from './Parser';\nimport {_Renderer} from './Renderer';\nimport {_TextRenderer} from './TextRenderer';\nimport {_Tokenizer} from './Tokenizer';\nimport type {Token, TokensList} from './Tokens';\n\nconst markedInstance = new Marked();\n\nexport function marked(src: string, opt?: MarkedOptions): string | Promise<string> {\n    return markedInstance.parse(src, opt);\n}\n\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options: MarkedOptions) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\n\nmarked.defaults = _defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function (...args: MarkedExtension[]) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function (tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\n\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport {_defaults as defaults, _getDefaults as getDefaults} from './defaults';\nexport {_Lexer as Lexer} from './Lexer';\nexport {_Parser as Parser} from './Parser';\nexport {_Tokenizer as Tokenizer} from './Tokenizer';\nexport {_Renderer as Renderer} from './Renderer';\nexport {_TextRenderer as TextRenderer} from './TextRenderer';\nexport {_Hooks as Hooks} from './Hooks';\nexport {Marked} from './Instance';\nexport type * from './MarkedOptions';\nexport type * from './rules';\nexport type * from './Tokens';\n","import {SnapshotParser} from '../../types/markdown/snapshotParser';\nimport {emptyInnerHtml} from '../../utils/dom/emptyInnerHtml';\nimport {insertCopyToClipboardButton} from '../copyToClipboard/insertCopyToClipboardButton';\nimport {marked} from './marked/marked';\n\nexport const parseMdSnapshot: SnapshotParser = (\n    snapshot,\n    options,\n): string => {\n\n    const {\n        showCodeBlockCopyButton,\n        markdownLinkTarget,\n        syntaxHighlighter,\n        htmlSanitizer,\n    } = options || {};\n\n    const parsedMarkdown = marked(snapshot, {\n        async: false,\n        breaks: true,\n    });\n\n    if (typeof parsedMarkdown !== 'string') {\n        throw new Error('Markdown parsing failed');\n    }\n\n    const element = document.createElement('div');\n    element.innerHTML = htmlSanitizer ? htmlSanitizer(parsedMarkdown) : parsedMarkdown;\n\n    element.querySelectorAll('pre').forEach((block) => {\n        const newBlock = document.createElement('div');\n        newBlock.className = 'code-block';\n\n        const codeElement = block.querySelector('code');\n        if (!codeElement) {\n            // No code can be found, so just copy the innerHTML of the block.\n            const html = block.innerHTML;\n            newBlock.innerHTML = htmlSanitizer ? htmlSanitizer(html) : html;\n            block.replaceWith(newBlock);\n            return;\n        }\n\n        //\n        // When a code block is found\n        // 1. Adjust the class name and HTML structure to style the code block\n        // 2. Apply syntax highlighting\n        // 3. Add a copy to clipboard button\n        // 4. Apply link target\n        //\n\n        let language: string | undefined;\n        for (let i = 0; i < codeElement.classList.length; i++) {\n            const className = codeElement.classList[i];\n            if (className.startsWith('language-')) {\n                language = className.slice(9);\n                break;\n            }\n        }\n\n        const newCodeElement = document.createElement('pre');\n        const newHtml = '<div>' + codeElement.innerHTML + '</div>';\n        newCodeElement.innerHTML = options?.htmlSanitizer ? options.htmlSanitizer(newHtml) : newHtml;\n\n        if (language) {\n            newCodeElement.setAttribute('data-language', language);\n\n            //\n            // Apply syntax highlighting\n            //\n            if (syntaxHighlighter) {\n                const highlight = syntaxHighlighter.createHighlighter();\n                const newHtml = '<div>' + highlight(codeElement.textContent || '', language) + '</div>';\n\n                newCodeElement.innerHTML = htmlSanitizer ? htmlSanitizer(newHtml) : newHtml;\n                newCodeElement.className = 'highlighter-dark';\n            }\n        }\n\n        emptyInnerHtml(newBlock);\n        newBlock.appendChild(newCodeElement);\n        block.replaceWith(newBlock);\n    });\n\n    if (showCodeBlockCopyButton !== false) { // Default to true\n        insertCopyToClipboardButton(element);\n    }\n\n    if (markdownLinkTarget !== 'self') { // Default to 'blank'\n        element.querySelectorAll('a').forEach((link) => {\n            link.setAttribute('target', '_blank');\n        });\n    }\n\n    return element.innerHTML;\n};\n","import {StandardStreamParser} from '../../types/markdown/streamParser';\nimport {warn} from '../../utils/warn';\nimport {attachCopyClickListener} from '../copyToClipboard/attachCopyClickListener';\nimport {parseMdSnapshot} from '../snapshot/snapshotParser';\n\nconst defaultDelayInMsBeforeComplete = 2000;\nconst defaultDelayInMsBetweenBufferChecks = 8;\nconst endOfStreamChar = '\\n';\n\nconst getScheduler = (type: 'timeout' | 'animationFrame') => {\n    if (type === 'timeout') {\n        return (callback: () => void) => setTimeout(callback, 0);\n    }\n\n    return (callback: () => void) => requestAnimationFrame(callback);\n};\n\nexport const createMdStreamRenderer: StandardStreamParser = (\n    root: HTMLElement,\n    options,\n) => {\n    let streamIsComplete = false;\n\n    const letterByLetter = true;\n    const {onComplete} = options || {};\n\n    //\n    // Buffer to store the chunks of markdown to be parsed\n    // Scheduler to control the speed of the streaming animation\n    //\n    const buffer: string[] = [];\n    const scheduler = getScheduler(\n        options?.skipStreamingAnimation ? 'timeout' : 'animationFrame',\n    );\n\n    //\n    // Container for markdown being parsed and that can be updated\n    //\n    const wipContainer = document.createElement('div');\n    wipContainer.classList.add('md-in-progress');\n    root.append(wipContainer);\n\n    //\n    // Functions to commit the WIP content to the DOM\n    // And to complete the parsing\n    //\n    const commitWipContent = () => {\n        while (wipContainer.firstChild) {\n            const childToCommit = wipContainer.firstChild;\n            if (childToCommit instanceof HTMLElement) {\n                attachCopyClickListener(childToCommit);\n            }\n\n            wipContainer.before(childToCommit);\n        }\n    };\n\n    const completeParsing = () => {\n        streamIsComplete = true;\n        if (parsingInterval) {\n            clearInterval(parsingInterval);\n            parsingInterval = undefined;\n        }\n\n        commitWipContent();\n        wipContainer.remove();\n        onComplete?.();\n    };\n\n    const delayBetweenBufferChecks = (\n        !options?.skipStreamingAnimation && options?.streamingAnimationSpeed && options.streamingAnimationSpeed >= 0\n    ) ? options.streamingAnimationSpeed : (options?.skipStreamingAnimation ? 0 : defaultDelayInMsBetweenBufferChecks);\n\n    const parsingContext: {\n        timeSinceLastProcessing: number;\n        currentMarkdown: string;\n        previousHtml: string | undefined;\n    } = {\n        timeSinceLastProcessing: new Date().getTime(),\n        currentMarkdown: '',\n        previousHtml: undefined,\n    };\n\n    let parsingInterval: number | undefined = setInterval(() => {\n        const nowTime = new Date().getTime();\n        const shouldAutomaticallyCompleteAfterDelay = options?.waitTimeBeforeStreamCompletion !== 'never';\n        if (buffer.length === 0 && shouldAutomaticallyCompleteAfterDelay) {\n            const delayBeforeCompleteParsing = (typeof options?.waitTimeBeforeStreamCompletion === 'number')\n                ? options.waitTimeBeforeStreamCompletion : defaultDelayInMsBeforeComplete;\n\n            if (streamIsComplete || nowTime - parsingContext.timeSinceLastProcessing > delayBeforeCompleteParsing) {\n                completeParsing();\n            }\n\n            return;\n        }\n\n        parsingContext.timeSinceLastProcessing = nowTime;\n        const chunk = buffer.shift();\n        if (chunk === undefined || typeof chunk !== 'string') {\n            return;\n        }\n\n        scheduler(() => {\n            // We should only parse the last chunk (in it release context) instead of the whole text\n            // In order to do that, we need to distinguish between:\n            //   - We will have WIP text to being parsed, and may be incomplete (example: `# Hello, `)\n            //   - Text that is committed to the DOM and will not change (example: `# Hello World!\\n\\n`)\n\n            // Append the new chunk to the raw text and parse\n            const markdownToParse = parsingContext.currentMarkdown + chunk;\n            const parsedHtml = parseMdSnapshot(markdownToParse, options).trim();\n\n            if (typeof parsedHtml !== 'string') {\n                // Remove the last chunk if parsing failed\n                parsingContext.currentMarkdown = parsingContext.currentMarkdown.slice(0, -chunk.length);\n                warn('Markdown parsing failed');\n                return;\n            }\n\n            if (\n                parsingContext.previousHtml &&\n                parsedHtml.length > parsingContext.previousHtml.length &&\n                parsedHtml.startsWith(parsingContext.previousHtml)\n            ) {\n                // Case 1: No changes to the previous HTML — And new HTML added on top of it\n                // Which means the new chunk added new HTML content outside the last parsed markdown\n                // Which means that the last parsed markdown is complete and should be committed to the DOM\n                // Commit the last parsed content to the DOM\n\n                commitWipContent();\n\n                // Extract new HTML and insert it into WIP container\n                const currentHtml = parsedHtml.slice(parsingContext.previousHtml.length).trim();\n                wipContainer.innerHTML = options?.htmlSanitizer ? options.htmlSanitizer(currentHtml) : currentHtml;\n\n                // Focus on everything that is new\n                parsingContext.currentMarkdown = chunk;\n                parsingContext.previousHtml = undefined;\n            } else {\n                // Case 2: Changes to the previous HTML\n                // This means that new chunk goes inside previous HTML and no root level changes\n\n                // Append the new chunk to the current markdown\n                wipContainer.innerHTML = options?.htmlSanitizer ? options.htmlSanitizer(parsedHtml) : parsedHtml;\n\n                // Update the current markdown and previous HTML for the next iteration\n                parsingContext.currentMarkdown = markdownToParse;\n                parsingContext.previousHtml = parsedHtml;\n            }\n        });\n    }, delayBetweenBufferChecks) as unknown as number;\n\n    return {\n        next: (chunk: string) => {\n            if (streamIsComplete) {\n                warn('Stream is already complete. No more chunks can be added');\n                return;\n            }\n\n            if (letterByLetter) {\n                for (const char of chunk) {\n                    buffer.push(char);\n                }\n            } else {\n                buffer.push(chunk);\n            }\n        },\n        complete: () => {\n            buffer.push(endOfStreamChar);\n            streamIsComplete = true;\n        },\n        cancel: () => {\n            if (parsingInterval) {\n                clearInterval(parsingInterval);\n                parsingInterval = undefined;\n            }\n\n            streamIsComplete = true;\n            wipContainer.remove();\n        },\n        error: () => {\n            // No special handling for errors\n            // Just complete the stream\n            streamIsComplete = true;\n        },\n    };\n};\n","import {HighlighterExtension} from '../../../js/core/src';\nimport {createMdStreamRenderer} from '../../../shared/src/markdown/stream/streamParser';\nimport {SanitizerExtension} from '../../../shared/src/sanitizer/sanitizer';\nimport {CallbackFunction} from '../../../shared/src/types/callbackFunction';\n\nexport type {SnapshotParser, SnapshotParserOptions} from '../../../shared/src/types/markdown/snapshotParser';\nexport {parseMdSnapshot} from '../../../shared/src/markdown/snapshot/snapshotParser';\n\nexport type MarkdownStreamParser = {\n    next(value: string): void;\n    complete(): void;\n};\n\nexport type MarkdownStreamParserOptions = {\n    markdownLinkTarget?: 'blank' | 'self';\n    syntaxHighlighter?: HighlighterExtension;\n    htmlSanitizer?: SanitizerExtension;\n    skipStreamingAnimation?: boolean;\n    streamingAnimationSpeed?: number;\n    waitTimeBeforeStreamCompletion?: number | 'never';\n    showCodeBlockCopyButton?: boolean;\n    onComplete?: CallbackFunction;\n};\n\nexport const createMarkdownStreamParser = (\n    domElement: HTMLElement,\n    options?: MarkdownStreamParserOptions,\n): MarkdownStreamParser => {\n    const nluxMarkdownStreamRenderer = createMdStreamRenderer(\n        domElement,\n        {\n            syntaxHighlighter: options?.syntaxHighlighter,\n            htmlSanitizer: options?.htmlSanitizer,\n            markdownLinkTarget: options?.markdownLinkTarget,\n            showCodeBlockCopyButton: options?.showCodeBlockCopyButton,\n            skipStreamingAnimation: options?.skipStreamingAnimation,\n            streamingAnimationSpeed: options?.streamingAnimationSpeed,\n            waitTimeBeforeStreamCompletion: options?.waitTimeBeforeStreamCompletion,\n            onComplete: options?.onComplete,\n        },\n    );\n\n    return {\n        next(value: string) {\n            nluxMarkdownStreamRenderer.next(value);\n        },\n        complete() {\n            nluxMarkdownStreamRenderer.complete();\n        },\n    };\n};\n"],"names":["__publicField","escape","text","args","ret","tokens","src","options","newHtml"],"mappings":"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"}