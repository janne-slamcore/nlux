{"version":3,"file":"markdown.js","sources":["../../../../packages/shared/src/utils/warn.ts","../../../../packages/shared/src/markdown/copyToClipboard/attachCopyClickListener.ts","../../../../packages/shared/src/utils/dom/emptyInnerHtml.ts","../../../../packages/shared/src/markdown/copyToClipboard/insertCopyToClipboardButton.ts","../../../../packages/shared/src/markdown/snapshot/marked/defaults.ts","../../../../packages/shared/src/markdown/snapshot/marked/Hooks.ts","../../../../packages/shared/src/markdown/snapshot/marked/helpers.ts","../../../../packages/shared/src/markdown/snapshot/marked/rules.ts","../../../../packages/shared/src/markdown/snapshot/marked/Tokenizer.ts","../../../../packages/shared/src/markdown/snapshot/marked/Lexer.ts","../../../../packages/shared/src/markdown/snapshot/marked/Renderer.ts","../../../../packages/shared/src/markdown/snapshot/marked/TextRenderer.ts","../../../../packages/shared/src/markdown/snapshot/marked/Parser.ts","../../../../packages/shared/src/markdown/snapshot/marked/Instance.ts","../../../../packages/shared/src/markdown/snapshot/marked/marked.ts","../../../../packages/shared/src/markdown/snapshot/snapshotParser.ts","../../../../packages/shared/src/markdown/stream/streamParser.ts","../../../../packages/extra/markdown/src/index.ts"],"sourcesContent":["export const warn = (message: unknown) => {\n    if (typeof message === 'string') {\n        console.warn(`[nlux] ${message}`);\n        return;\n    }\n\n    if (message && typeof message.toString === 'function') {\n        console.warn(`[nlux] ${message.toString()}`);\n        return;\n    }\n\n    console.warn('[nlux]');\n    console.log(JSON.stringify(message, null, 2));\n};\n\nconst warnedMessages: string[] = [];\nexport const warnOnce = (message: string) => {\n    if (warnedMessages.includes(message)) {\n        return;\n    }\n\n    warnedMessages.push(message);\n    warn(message);\n};\n","const addListenersToCopyButton = (copyButton: Element) => {\n    if (!(copyButton instanceof HTMLButtonElement)) {\n        return;\n    }\n\n    // If button has click event listener, do not add another one\n    if (copyButton.dataset.clickListenerSet === 'true') {\n        return;\n    }\n\n    let clicked = false;\n    const codeBlock = copyButton.nextElementSibling as HTMLElement;\n    copyButton.addEventListener('click', () => {\n        if (clicked || !codeBlock) {\n            return;\n        }\n\n        // Copy code to clipboard\n        const code = codeBlock.innerText;\n        navigator.clipboard.writeText(code ?? '');\n\n        // Mark button as clicked for 1 second\n        clicked = true;\n        copyButton.classList.add('clicked');\n        setTimeout(() => {\n            clicked = false;\n            copyButton.classList.remove('clicked');\n        }, 1000);\n    });\n\n    // Set data attribute to indicate that click event listener has been set\n    copyButton.dataset.clickListenerSet = 'true';\n};\n\nexport const attachCopyClickListener = (markdownContainer: HTMLElement) => {\n    const copyButtonCssClass = 'nlux-comp-copyButton';\n    if (\n        markdownContainer instanceof HTMLButtonElement &&\n        markdownContainer.classList.contains(copyButtonCssClass)\n    ) {\n        addListenersToCopyButton(markdownContainer);\n        return;\n    }\n\n    markdownContainer.querySelectorAll(`.${copyButtonCssClass}`).forEach(addListenersToCopyButton);\n};\n","export const emptyInnerHtml = (element: HTMLElement): void => {\n    element.replaceChildren();\n};\n","export const insertCopyToClipboardButton = (markdownContainer: HTMLElement) => {\n    markdownContainer.querySelectorAll('.code-block').forEach((codeBlockContainer) => {\n        const codeBlock = codeBlockContainer.querySelector('pre');\n        if (!codeBlock) {\n            return;\n        }\n\n        // Check the adjacent element to see if a copy button is already present\n        if (codeBlockContainer.previousElementSibling?.classList.contains('nlux-comp-copyButton')) {\n            return;\n        }\n\n        const title = 'Copy code block to clipboard';\n        const copyButton = document.createElement('button');\n\n        copyButton.classList.add('nlux-comp-copyButton');\n        copyButton.setAttribute('aria-label', title);\n        copyButton.setAttribute('title', title);\n\n        const copyIcon = document.createElement('span');\n        copyIcon.classList.add('icon-copy');\n        copyButton.appendChild(copyIcon);\n\n        codeBlockContainer.appendChild(copyButton);\n    });\n};\n","import type {MarkedOptions} from './MarkedOptions';\n\n/**\n * Gets the original marked default options.\n */\nexport function _getDefaults(): MarkedOptions {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\n\nexport let _defaults = _getDefaults();\n\nexport function changeDefaults(newDefaults: MarkedOptions) {\n    _defaults = newDefaults;\n}\n","import {_defaults} from './defaults';\nimport type {MarkedOptions} from './MarkedOptions';\nimport type {Token, TokensList} from './Tokens';\n\nexport class _Hooks {\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    options: MarkedOptions;\n\n    constructor(options?: MarkedOptions) {\n        this.options = options || _defaults;\n    }\n\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html: string) {\n        return html;\n    }\n\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown: string) {\n        return markdown;\n    }\n\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens: Token[] | TokensList) {\n        return tokens;\n    }\n}\n","/**\n * Helpers\n */\nconst escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, 'g');\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, 'g');\nconst escapeReplacements: {[index: string]: string} = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n};\nconst getEscapeReplacement = (ch: string) => escapeReplacements[ch];\n\nexport function escape(html: string, encode?: boolean) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n\n    return html;\n}\n\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\nexport function unescape(html: string) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n) => {\n        n = n.toLowerCase();\n        if (n === 'colon') {\n            return ':';\n        }\n        if (n.charAt(0) === '#') {\n            return n.charAt(1) === 'x'\n                ? String.fromCharCode(parseInt(n.substring(2), 16))\n                : String.fromCharCode(+n.substring(1));\n        }\n        return '';\n    });\n}\n\nconst caret = /(^|[^\\[])\\^/g;\n\nexport function edit(regex: string | RegExp, opt?: string) {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    opt = opt || '';\n    const obj = {\n        replace: (name: string | RegExp, val: string | RegExp) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\n\nexport function cleanUrl(href: string) {\n    try {\n        href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\n\nexport const noopTest = {exec: () => null} as unknown as RegExp;\n\nexport function splitCells(tableRow: string, count?: number) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str) => {\n            let escaped = false;\n            let curr = offset;\n            while (--curr >= 0 && str[curr] === '\\\\') {\n                escaped = !escaped;\n            }\n            if (escaped) {\n                // odd number of slashes means | is escaped\n                // so we leave it alone\n                return '|';\n            } else {\n                // add space before unescaped |\n                return ' |';\n            }\n        }),\n        cells = row.split(/ \\|/);\n    let i = 0;\n\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while (cells.length < count) {\n                cells.push('');\n            }\n        }\n    }\n\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n    return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str: string, c: string, invert?: boolean) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else {\n            if (currChar !== c && invert) {\n                suffLen++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return str.slice(0, l - suffLen);\n}\n\nexport function findClosingBracket(str: string, b: string) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        } else {\n            if (str[i] === b[0]) {\n                level++;\n            } else {\n                if (str[i] === b[1]) {\n                    level--;\n                    if (level < 0) {\n                        return i;\n                    }\n                }\n            }\n        }\n    }\n    return -1;\n}\n","import {edit, noopTest} from './helpers';\n\n/**\n * Block-Level Grammar\n */\n\nconst newline = /^(?: *(?:\\n|$))+/;\nconst blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(\n    /^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, / {4}/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\n\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\n\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\n    '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7)\n    // closing\n    // tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\n\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\n\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n\ntype BlockKeys = keyof typeof blockNormal;\n\n/**\n * GFM Block Grammar\n */\n\nconst gfmTable = edit(\n    '^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', ' {4}[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\n\nconst blockGfm: Record<BlockKeys, RegExp> = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nconst blockPedantic: Record<BlockKeys, RegExp> = {\n    ...blockNormal,\n    html: edit(\n        '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n            + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n            + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n            + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n\n/**\n * Inline-Level Grammar\n */\n\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = '\\\\p{P}\\\\p{S}';\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, 'u')\n    .replace(/punctuation/g, _punctuation).getRegex();\n\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\n\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n\nconst emStrongRDelimAst = edit(\n    '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])' // (5) #***# can be either Left or Right Delimiter\n    + '|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])', 'gu') // (6) a***a can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\n    '^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)[punct](_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=[punct])' // (4) ___# can only be Left Delimiter\n    + '|(?!_)[punct](_+)(?!_)(?=[punct])', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n\nconst anyPunctuation = edit(/\\\\([punct])/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\n\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email',\n        /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,\n    )\n    .getRegex();\n\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit(\n    '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\n\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\n\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\n\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\n\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n\ntype InlineKeys = keyof typeof inlineNormal;\n\n/**\n * Pedantic Inline Grammar\n */\n\nconst inlinePedantic: Record<InlineKeys, RegExp> = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n\n/**\n * GFM Inline Grammar\n */\n\nconst inlineGfm: Record<InlineKeys, RegExp> = {\n    ...inlineNormal,\n    escape: edit(escape).replace('])', '~|])').getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\nconst inlineBreaks: Record<InlineKeys, RegExp> = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n\n/**\n * exports\n */\n\nexport const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\n\nexport const inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n\nexport interface Rules {\n    block: Record<BlockKeys, RegExp>;\n    inline: Record<InlineKeys, RegExp>;\n}\n","import {_defaults} from './defaults';\nimport {escape, findClosingBracket, rtrim, splitCells} from './helpers';\nimport type {_Lexer} from './Lexer';\nimport type {MarkedOptions} from './MarkedOptions';\nimport type {Rules} from './rules';\nimport type {Links, Tokens} from './Tokens';\n\nfunction outputLink(cap: string[], link: Pick<Tokens.Link, 'href' | 'title'>, raw: string, lexer: _Lexer): Tokens.Link | Tokens.Image {\n    const href = link.href;\n    const title = link.title ? escape(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token: Tokens.Link = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text: escape(text),\n    };\n}\n\nfunction indentCodeCompensation(raw: string, text: string) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n        return text;\n    }\n\n    const indentToCode = matchIndentToCode[1];\n\n    return text\n        .split('\\n')\n        .map(node => {\n            const matchIndentInNode = node.match(/^\\s+/);\n            if (matchIndentInNode === null) {\n                return node;\n            }\n\n            const [indentInNode] = matchIndentInNode;\n\n            if (indentInNode.length >= indentToCode.length) {\n                return node.slice(indentToCode.length);\n            }\n\n            return node;\n        })\n        .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nexport class _Tokenizer {\n    lexer!: _Lexer; // set by the lexer\n    options: MarkedOptions;\n    rules!: Rules; // set by the lexer\n\n    constructor(options?: MarkedOptions) {\n        this.options = options || _defaults;\n    }\n\n    autolink(src: string): Tokens.Link | undefined {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[1]);\n                href = 'mailto:' + text;\n            } else {\n                text = escape(cap[1]);\n                href = text;\n            }\n\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n\n    blockquote(src: string): Tokens.Blockquote | undefined {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            // precede setext continuation with 4 spaces so it isn't a setext\n            let text = cap[0].replace(/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g, '\\n    $1');\n            text = rtrim(text.replace(/^ *>[ \\t]?/gm, ''), '\\n');\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: 'blockquote',\n                raw: cap[0],\n                tokens,\n                text,\n            };\n        }\n    }\n\n    br(src: string): Tokens.Br | undefined {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n\n    code(src: string): Tokens.Code | undefined {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n\n    codespan(src: string): Tokens.Codespan | undefined {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, ' ');\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape(text, true);\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n\n    def(src: string): Tokens.Def | undefined {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation,\n                '$1',\n            ) : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n\n    del(src: string): Tokens.Del | undefined {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n\n    emStrong(src: string, maskedSrc: string, prevChar = ''): Tokens.Em | Tokens.Strong | undefined {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match) {\n            return;\n        }\n\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) {\n            return;\n        }\n\n        const nextChar = match[1] || match[2] || '';\n\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...(match as any)[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n            const endReg = match[0][0] === '*'\n                ? this.rules.inline.emStrongRDelimAst\n                : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n                if (!rDelim) {\n                    continue;\n                } // skip single * in __abc*abc__\n\n                rLength = [...rDelim].length;\n\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                } else {\n                    if (match[5] || match[6]) { // either Left or Right Delim\n                        if (lLength % 3 && !((lLength + rLength) % 3)) {\n                            midDelimTotal += rLength;\n                            continue; // CommonMark Emphasis Rules 9-10\n                        }\n                    }\n                }\n\n                delimTotal -= rLength;\n\n                if (delimTotal > 0) {\n                    continue;\n                } // Haven't found enough closing delimiters\n\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...(match as any)[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n\n    escape(src: string): Tokens.Escape | undefined {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: escape(cap[1]),\n            };\n        }\n    }\n\n    fences(src: string): Tokens.Code | undefined {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '');\n\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n\n    heading(src: string): Tokens.Heading | undefined {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else {\n                    if (!trimmed || / $/.test(trimmed)) {\n                        // CommonMark requires space before trailing #s\n                        text = trimmed.trim();\n                    }\n                }\n            }\n\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n\n    hr(src: string): Tokens.Hr | undefined {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: cap[0],\n            };\n        }\n    }\n\n    html(src: string): Tokens.HTML | undefined {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token: Tokens.HTML = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n\n    inlineText(src: string): Tokens.Text | undefined {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            } else {\n                text = escape(cap[0]);\n            }\n            return {\n                type: 'text',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n\n    lheading(src: string): Tokens.Heading | undefined {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n\n    link(src: string): Tokens.Link | Tokens.Image | undefined {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(/>$/.test(trimmedUrl))) {\n                    return;\n                }\n\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !(/>$/.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer);\n        }\n    }\n\n    list(src: string): Tokens.List | undefined {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n\n            const list: Tokens.List = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let raw = '';\n            let itemContents = '';\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n\n                raw = cap[0];\n                src = src.substring(raw.length);\n\n                let line = cap[2].split('\\n', 1)[0].replace(/^\\t+/, (t: string) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n\n                let blankLine = false;\n\n                if (!line && /^ *$/.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(\n                        `^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(\n                        `^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        nextLine = rawLine;\n\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n                        }\n\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n\n                            itemContents += '\\n' + nextLine;\n                        }\n\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else {\n                        if (/\\n *\\n *$/.test(raw)) {\n                            endsWithBlankLine = true;\n                        }\n                    }\n                }\n\n                let istask: RegExpExecArray | null = null;\n                let ischecked: boolean | undefined;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n                    }\n                }\n\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n\n                list.raw += raw;\n            }\n\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to\n            // simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimEnd();\n            (list.items[list.items.length - 1]).text = itemContents.trimEnd();\n            list.raw = list.raw.trimEnd();\n\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => /\\n.*\\n/.test(t.raw));\n\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n\n            return list;\n        }\n    }\n\n    paragraph(src: string): Tokens.Paragraph | undefined {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n\n    reflink(src: string, links: Links): Tokens.Link | Tokens.Image | Tokens.Text | undefined {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n\n    space(src: string): Tokens.Space | undefined {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n\n    table(src: string): Tokens.Table | undefined {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, '').split('|');\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, '').split('\\n') : [];\n\n        const item: Tokens.Table = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n\n        for (const align of aligns) {\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push('right');\n            } else {\n                if (/^ *:-+: *$/.test(align)) {\n                    item.align.push('center');\n                } else {\n                    if (/^ *:-+ *$/.test(align)) {\n                        item.align.push('left');\n                    } else {\n                        item.align.push(null);\n                    }\n                }\n            }\n        }\n\n        for (const header of headers) {\n            item.header.push({\n                text: header,\n                tokens: this.lexer.inline(header),\n            });\n        }\n\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map(cell => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                };\n            }));\n        }\n\n        return item;\n    }\n\n    tag(src: string): Tokens.Tag | undefined {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else {\n                if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                    this.lexer.state.inLink = false;\n                }\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else {\n                if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                    this.lexer.state.inRawBlock = false;\n                }\n            }\n\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n\n    text(src: string): Tokens.Text | undefined {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n\n    url(src: string): Tokens.Link | undefined {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = escape(cap[0]);\n                href = 'mailto:' + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                }\n                while (prevCapZero !== cap[0]);\n                text = escape(cap[0]);\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n}\n","import {_defaults} from './defaults';\nimport type {MarkedOptions, TokenizerExtension} from './MarkedOptions';\nimport {block, inline} from './rules';\nimport {_Tokenizer} from './Tokenizer';\nimport type {Token, Tokens, TokensList} from './Tokens';\n\n/**\n * Block Lexer\n */\nexport class _Lexer {\n    options: MarkedOptions;\n    state: {\n        inLink: boolean;\n        inRawBlock: boolean;\n        top: boolean;\n    };\n    tokens: TokensList;\n    private inlineQueue: {src: string, tokens: Token[]}[];\n    private tokenizer: _Tokenizer;\n\n    constructor(options?: MarkedOptions) {\n        // TokenList cannot be created in one go\n        this.tokens = [] as unknown as TokensList;\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n\n        const rules = {\n            block: block.normal,\n            inline: inline.normal,\n        };\n\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else {\n            if (this.options.gfm) {\n                rules.block = block.gfm;\n                if (this.options.breaks) {\n                    rules.inline = inline.breaks;\n                } else {\n                    rules.inline = inline.gfm;\n                }\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n\n    /**\n     * Static Lex Method\n     */\n    static lex(src: string, options?: MarkedOptions) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src: string, options?: MarkedOptions) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n\n    /**\n     * Lexing\n     */\n    blockTokens(src: string, tokens?: Token[]): Token[];\n\n    blockTokens(src: string, tokens?: TokensList): TokensList;\n\n    blockTokens(src: string, tokens: Token[] = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, '    ').replace(/^ +$/gm, '');\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs) => {\n                return leading + '    '.repeat(tabs.length);\n            });\n        }\n\n        let token: Tokens.Generic | undefined;\n        let lastToken;\n        let cutSrc;\n        let lastParagraphClipped;\n\n        while (src) {\n            if (this.options.extensions\n                && this.options.extensions.block\n                && this.options.extensions.block.some((extTokenizer: TokenizerExtension['tokenizer']) => {\n                    if (token = extTokenizer.call({lexer: this}, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += '\\n';\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    if (!this.tokens.links[token.tag]) {\n                        this.tokens.links[token.tag] = {\n                            href: token.href,\n                            title: token.title,\n                        };\n                    }\n                }\n                continue;\n            }\n\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({lexer: this}, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = (cutSrc.length !== src.length);\n                src = src.substring(token.raw.length);\n                continue;\n            }\n\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n\n        this.state.top = true;\n        return tokens;\n    }\n\n    inline(src: string, tokens: Token[] = []) {\n        this.inlineQueue.push({src, tokens});\n        return tokens;\n    }\n\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src: string, tokens: Token[] = []): Token[] {\n        let token, lastToken, cutSrc;\n\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']'\n                            + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(\n                this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(\n                this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n\n            // extensions\n            if (this.options.extensions\n                && this.options.extensions.inline\n                && this.options.extensions.inline.some((extTokenizer) => {\n                    if (token = extTokenizer.call({lexer: this}, src, tokens)) {\n                        src = src.substring(token.raw.length);\n                        tokens.push(token);\n                        return true;\n                    }\n                    return false;\n                })) {\n                continue;\n            }\n\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({lexer: this}, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Preprocessing\n     */\n    lex(src: string) {\n        src = src\n            .replace(/\\r\\n|\\r/g, '\\n');\n\n        this.blockTokens(src, this.tokens);\n\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n\n        return this.tokens;\n    }\n}\n","import {_defaults} from './defaults';\nimport {cleanUrl, escape} from './helpers';\nimport type {MarkedOptions} from './MarkedOptions';\n\n/**\n * Renderer\n */\nexport class _Renderer {\n    options: MarkedOptions;\n\n    constructor(options?: MarkedOptions) {\n        this.options = options || _defaults;\n    }\n\n    blockquote(quote: string): string {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n\n    br(): string {\n        return '<br>';\n    }\n\n    checkbox(checked: boolean): string {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n\n    code(code: string, infostring: string | undefined, escaped: boolean): string {\n        const lang = (infostring || '').match(/^\\S*/)?.[0];\n\n        code = code.replace(/\\n$/, '') + '\\n';\n\n        if (!lang) {\n            return '<pre><code>'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n\n        return '<pre><code class=\"language-'\n            + escape(lang)\n            + '\">'\n            + (escaped ? code : escape(code, true))\n            + '</code></pre>\\n';\n    }\n\n    codespan(text: string): string {\n        return `<code>${text}</code>`;\n    }\n\n    del(text: string): string {\n        return `<del>${text}</del>`;\n    }\n\n    em(text: string): string {\n        return `<em>${text}</em>`;\n    }\n\n    heading(text: string, level: number, raw: string): string {\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n\n    hr(): string {\n        return '<hr>\\n';\n    }\n\n    html(html: string, block?: boolean): string {\n        return html;\n    }\n\n    image(href: string, title: string | null, text: string): string {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += '>';\n        return out;\n    }\n\n    link(href: string, title: string | null | undefined, text: string): string {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n\n    list(body: string, ordered: boolean, start: number | ''): string {\n        const type = ordered ? 'ol' : 'ul';\n        const startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    }\n\n    listitem(text: string, task: boolean, checked: boolean): string {\n        return `<li>${text}</li>\\n`;\n    }\n\n    paragraph(text: string): string {\n        return `<p>${text}</p>\\n`;\n    }\n\n    /**\n     * span level renderer\n     */\n    strong(text: string): string {\n        return `<strong>${text}</strong>`;\n    }\n\n    table(header: string, body: string): string {\n        if (body) {\n            body = `<tbody>${body}</tbody>`;\n        }\n\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n\n    tablecell(content: string, flags: {\n        header: boolean;\n        align: 'center' | 'left' | 'right' | null;\n    }): string {\n        const type = flags.header ? 'th' : 'td';\n        const tag = flags.align\n            ? `<${type} align=\"${flags.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n\n    tablerow(content: string): string {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n\n    text(text: string): string {\n        return text;\n    }\n}\n","/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer {\n    br() {\n        return '';\n    }\n\n    codespan(text: string) {\n        return text;\n    }\n\n    del(text: string) {\n        return text;\n    }\n\n    em(text: string) {\n        return text;\n    }\n\n    html(text: string) {\n        return text;\n    }\n\n    image(href: string, title: string | null, text: string) {\n        return '' + text;\n    }\n\n    link(href: string, title: string | null | undefined, text: string) {\n        return '' + text;\n    }\n\n    // no need for block level renderers\n    strong(text: string) {\n        return text;\n    }\n\n    text(text: string) {\n        return text;\n    }\n}\n","import {_defaults} from './defaults';\nimport {unescape} from './helpers';\nimport type {MarkedOptions} from './MarkedOptions';\nimport {_Renderer} from './Renderer';\nimport {_TextRenderer} from './TextRenderer';\nimport type {Token, Tokens} from './Tokens';\n\n/**\n * Parsing & Compiling\n */\nexport class _Parser {\n    options: MarkedOptions;\n    renderer: _Renderer;\n    textRenderer: _TextRenderer;\n\n    constructor(options?: MarkedOptions) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new _TextRenderer();\n    }\n\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens: Token[], options?: MarkedOptions) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens: Token[], options?: MarkedOptions) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n\n    /**\n     * Parse Loop\n     */\n    parse(tokens: Token[], top = true): string {\n        let out = '';\n\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers\n                && this.options.extensions.renderers[token.type]) {\n                const genericToken = token as Tokens.Generic;\n                const ret = this.options.extensions.renderers[genericToken.type].call({parser: this}, genericToken);\n                if (ret !== false || ![\n                    'space',\n                    'hr',\n                    'heading',\n                    'code',\n                    'table',\n                    'blockquote',\n                    'list',\n                    'html',\n                    'paragraph',\n                    'text',\n                ].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n\n            switch (token.type) {\n                case 'space': {\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr();\n                    continue;\n                }\n                case 'heading': {\n                    const headingToken = token as Tokens.Heading;\n                    out += this.renderer.heading(\n                        this.parseInline(headingToken.tokens),\n                        headingToken.depth,\n                        unescape(this.parseInline(headingToken.tokens, this.textRenderer)),\n                    );\n                    continue;\n                }\n                case 'code': {\n                    const codeToken = token as Tokens.Code;\n                    out += this.renderer.code(codeToken.text,\n                        codeToken.lang,\n                        !!codeToken.escaped,\n                    );\n                    continue;\n                }\n                case 'table': {\n                    const tableToken = token as Tokens.Table;\n                    let header = '';\n\n                    // header\n                    let cell = '';\n                    for (let j = 0; j < tableToken.header.length; j++) {\n                        cell += this.renderer.tablecell(\n                            this.parseInline(tableToken.header[j].tokens),\n                            {header: true, align: tableToken.align[j]},\n                        );\n                    }\n                    header += this.renderer.tablerow(cell);\n\n                    let body = '';\n                    for (let j = 0; j < tableToken.rows.length; j++) {\n                        const row = tableToken.rows[j];\n\n                        cell = '';\n                        for (let k = 0; k < row.length; k++) {\n                            cell += this.renderer.tablecell(\n                                this.parseInline(row[k].tokens),\n                                {header: false, align: tableToken.align[k]},\n                            );\n                        }\n\n                        body += this.renderer.tablerow(cell);\n                    }\n                    out += this.renderer.table(header, body);\n                    continue;\n                }\n                case 'blockquote': {\n                    const blockquoteToken = token as Tokens.Blockquote;\n                    const body = this.parse(blockquoteToken.tokens);\n                    out += this.renderer.blockquote(body);\n                    continue;\n                }\n                case 'list': {\n                    const listToken = token as Tokens.List;\n                    const ordered = listToken.ordered;\n                    const start = listToken.start;\n                    const loose = listToken.loose;\n\n                    let body = '';\n                    for (let j = 0; j < listToken.items.length; j++) {\n                        const item = listToken.items[j];\n                        const checked = item.checked;\n                        const task = item.task;\n\n                        let itemBody = '';\n                        if (item.task) {\n                            const checkbox = this.renderer.checkbox(!!checked);\n                            if (loose) {\n                                if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0\n                                        && item.tokens[0].tokens[0].type === 'text') {\n                                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                                    }\n                                } else {\n                                    item.tokens.unshift({\n                                        type: 'text',\n                                        text: checkbox + ' ',\n                                    } as Tokens.Text);\n                                }\n                            } else {\n                                itemBody += checkbox + ' ';\n                            }\n                        }\n\n                        itemBody += this.parse(item.tokens, loose);\n                        body += this.renderer.listitem(itemBody, task, !!checked);\n                    }\n\n                    out += this.renderer.list(body, ordered, start);\n                    continue;\n                }\n                case 'html': {\n                    const htmlToken = token as Tokens.HTML;\n                    out += this.renderer.html(htmlToken.text, htmlToken.block);\n                    continue;\n                }\n                case 'paragraph': {\n                    const paragraphToken = token as Tokens.Paragraph;\n                    out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token as Tokens.Text;\n                    let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i] as Tokens.Text;\n                        body += '\\n' + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                    }\n                    out += top ? this.renderer.paragraph(body) : body;\n                    continue;\n                }\n\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    } else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens: Token[], renderer?: _Renderer | _TextRenderer): string {\n        renderer = renderer || this.renderer;\n        let out = '';\n\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers\n                && this.options.extensions.renderers[token.type]) {\n                const ret = this.options.extensions.renderers[token.type].call({parser: this}, token);\n                if (ret !== false || ![\n                    'escape',\n                    'html',\n                    'link',\n                    'image',\n                    'strong',\n                    'em',\n                    'codespan',\n                    'br',\n                    'del',\n                    'text',\n                ].includes(token.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n\n            switch (token.type) {\n                case 'escape': {\n                    const escapeToken = token as Tokens.Escape;\n                    out += renderer.text(escapeToken.text);\n                    break;\n                }\n                case 'html': {\n                    const tagToken = token as Tokens.Tag;\n                    out += renderer.html(tagToken.text);\n                    break;\n                }\n                case 'link': {\n                    const linkToken = token as Tokens.Link;\n                    out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                    break;\n                }\n                case 'image': {\n                    const imageToken = token as Tokens.Image;\n                    out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                    break;\n                }\n                case 'strong': {\n                    const strongToken = token as Tokens.Strong;\n                    out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                    break;\n                }\n                case 'em': {\n                    const emToken = token as Tokens.Em;\n                    out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                    break;\n                }\n                case 'codespan': {\n                    const codespanToken = token as Tokens.Codespan;\n                    out += renderer.codespan(codespanToken.text);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br();\n                    break;\n                }\n                case 'del': {\n                    const delToken = token as Tokens.Del;\n                    out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                    break;\n                }\n                case 'text': {\n                    const textToken = token as Tokens.Text;\n                    out += renderer.text(textToken.text);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    } else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n","import {_getDefaults} from './defaults';\nimport {escape} from './helpers';\nimport {_Hooks} from './Hooks';\nimport {_Lexer} from './Lexer';\nimport type {MarkedExtension, MarkedOptions} from './MarkedOptions';\nimport {_Parser} from './Parser';\nimport {_Renderer} from './Renderer';\nimport {_TextRenderer} from './TextRenderer';\nimport {_Tokenizer} from './Tokenizer';\nimport type {Token, Tokens, TokensList} from './Tokens';\n\nexport type MaybePromise = void | Promise<void>;\n\ntype UnknownFunction = (...args: unknown[]) => unknown;\ntype GenericRendererFunction = (...args: unknown[]) => string | false;\n\nexport class Marked {\n    Hooks = _Hooks;\n    Lexer = _Lexer;\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Tokenizer = _Tokenizer;\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n    parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n\n    constructor(...args: MarkedExtension[]) {\n        this.use(...args);\n    }\n\n    lexer(src: string, options?: MarkedOptions) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n\n    parser(tokens: Token[], options?: MarkedOptions) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n\n    setOptions(opt: MarkedOptions) {\n        this.defaults = {...this.defaults, ...opt};\n        return this;\n    }\n\n    use(...args: MarkedExtension[]) {\n        const extensions: MarkedOptions['extensions'] = this.defaults.extensions || {renderers: {}, childTokens: {}};\n\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = {...pack} as unknown as MarkedOptions;\n\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error('extension level must be \\'block\\' or \\'inline\\'');\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            } else {\n                                if (ext.level === 'inline') {\n                                    if (extensions.startInline) {\n                                        extensions.startInline.push(ext.start);\n                                    } else {\n                                        extensions.startInline = [ext.start];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (prop === 'options') {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop as Exclude<keyof _Renderer, 'options'>;\n                    const rendererFunc = pack.renderer[rendererProp] as GenericRendererFunction;\n                    const prevRenderer = renderer[rendererProp] as GenericRendererFunction;\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args: unknown[]) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop as Exclude<keyof _Tokenizer, 'options' | 'rules' | 'lexer'>;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp] as UnknownFunction;\n                    const prevTokenizer = tokenizer[tokenizerProp] as UnknownFunction;\n\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-ignore\n                    tokenizer[tokenizerProp] = (...args: unknown[]) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (prop === 'options') {\n                        // ignore options property\n                        continue;\n                    }\n                    const hooksProp = prop as Exclude<keyof _Hooks, 'options'>;\n                    const hooksFunc = pack.hooks[hooksProp] as UnknownFunction;\n                    const prevHook = hooks[hooksProp] as UnknownFunction;\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-ignore\n                        hooks[hooksProp] = (arg: unknown) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        // @ts-ignore\n                        hooks[hooksProp] = (...args: unknown[]) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values: MaybePromise[] = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n\n            this.defaults = {...this.defaults, ...opts};\n        });\n\n        return this;\n    }\n\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n        let values: MaybePromise[] = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token as Tokens.Table;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token as Tokens.List;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token as Tokens.Generic;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity) as Token[] | TokensList;\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    } else {\n                        if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n                }\n            }\n        }\n        return values;\n    }\n\n    // @ts-ignore\n    #onError(silent: boolean, async: boolean) {\n        return (e: Error): string | Promise<string> => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n\n    // @ts-ignore\n    #parseMarkdown(lexer: (src: string, options?: MarkedOptions) => TokensList | Token[], parser: (tokens: Token[], options?: MarkedOptions) => string) {\n        return (src: string, options?: MarkedOptions | undefined | null): string | Promise<string> => {\n            const origOpt = {...options};\n            const opt = {...this.defaults, ...origOpt};\n\n            // Show warning if an extension set async to true but the parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                if (!opt.silent) {\n                    console.warn(\n                        'marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.');\n                }\n\n                opt.async = true;\n            }\n\n            const throwError = this.#onError(!!opt.silent, !!opt.async);\n\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                              .then(src => lexer(src, opt))\n                              .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                              .then(\n                                  tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(\n                                      () => tokens) : tokens)\n                              .then(tokens => parser(tokens, opt))\n                              .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                              .catch(throwError);\n            }\n\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src) as string;\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens) as Token[] | TokensList;\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html) as string;\n                }\n                return html;\n            } catch (e) {\n                return throwError(e as Error);\n            }\n        };\n    }\n}\n","import {_defaults, _getDefaults, changeDefaults} from './defaults';\nimport {_Hooks} from './Hooks';\nimport type {MaybePromise} from './Instance';\nimport {Marked} from './Instance';\nimport {_Lexer} from './Lexer';\nimport type {MarkedExtension, MarkedOptions} from './MarkedOptions';\nimport {_Parser} from './Parser';\nimport {_Renderer} from './Renderer';\nimport {_TextRenderer} from './TextRenderer';\nimport {_Tokenizer} from './Tokenizer';\nimport type {Token, TokensList} from './Tokens';\n\nconst markedInstance = new Marked();\n\nexport function marked(src: string, opt?: MarkedOptions): string | Promise<string> {\n    return markedInstance.parse(src, opt);\n}\n\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options: MarkedOptions) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\n\nmarked.defaults = _defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function (...args: MarkedExtension[]) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function (tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\n\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport {_defaults as defaults, _getDefaults as getDefaults} from './defaults';\nexport {_Lexer as Lexer} from './Lexer';\nexport {_Parser as Parser} from './Parser';\nexport {_Tokenizer as Tokenizer} from './Tokenizer';\nexport {_Renderer as Renderer} from './Renderer';\nexport {_TextRenderer as TextRenderer} from './TextRenderer';\nexport {_Hooks as Hooks} from './Hooks';\nexport {Marked} from './Instance';\nexport type * from './MarkedOptions';\nexport type * from './rules';\nexport type * from './Tokens';\n","import {SnapshotParser} from '../../types/markdown/snapshotParser';\nimport {emptyInnerHtml} from '../../utils/dom/emptyInnerHtml';\nimport {insertCopyToClipboardButton} from '../copyToClipboard/insertCopyToClipboardButton';\nimport {marked} from './marked/marked';\n\nexport const parseMdSnapshot: SnapshotParser = (\n    snapshot,\n    options,\n): string => {\n\n    const {\n        showCodeBlockCopyButton,\n        markdownLinkTarget,\n        syntaxHighlighter,\n        htmlSanitizer,\n    } = options || {};\n\n    const parsedMarkdown = marked(snapshot, {\n        async: false,\n        breaks: true,\n    });\n\n    if (typeof parsedMarkdown !== 'string') {\n        throw new Error('Markdown parsing failed');\n    }\n\n    const element = document.createElement('div');\n    element.innerHTML = htmlSanitizer ? htmlSanitizer(parsedMarkdown) : parsedMarkdown;\n\n    element.querySelectorAll('pre').forEach((block) => {\n        const newBlock = document.createElement('div');\n        newBlock.className = 'code-block';\n\n        const codeElement = block.querySelector('code');\n        if (!codeElement) {\n            // No code can be found, so just copy the innerHTML of the block.\n            const html = block.innerHTML;\n            newBlock.innerHTML = htmlSanitizer ? htmlSanitizer(html) : html;\n            block.replaceWith(newBlock);\n            return;\n        }\n\n        //\n        // When a code block is found\n        // 1. Adjust the class name and HTML structure to style the code block\n        // 2. Apply syntax highlighting\n        // 3. Add a copy to clipboard button\n        // 4. Apply link target\n        //\n\n        let language: string | undefined;\n        for (let i = 0; i < codeElement.classList.length; i++) {\n            const className = codeElement.classList[i];\n            if (className.startsWith('language-')) {\n                language = className.slice(9);\n                break;\n            }\n        }\n\n        const newCodeElement = document.createElement('pre');\n        const newHtml = '<div>' + codeElement.innerHTML + '</div>';\n        newCodeElement.innerHTML = options?.htmlSanitizer ? options.htmlSanitizer(newHtml) : newHtml;\n\n        if (language) {\n            newCodeElement.setAttribute('data-language', language);\n\n            //\n            // Apply syntax highlighting\n            //\n            if (syntaxHighlighter) {\n                const highlight = syntaxHighlighter.createHighlighter();\n                const newHtml = '<div>' + highlight(codeElement.textContent || '', language) + '</div>';\n\n                newCodeElement.innerHTML = htmlSanitizer ? htmlSanitizer(newHtml) : newHtml;\n                newCodeElement.className = 'highlighter-dark';\n            }\n        }\n\n        emptyInnerHtml(newBlock);\n        newBlock.appendChild(newCodeElement);\n        block.replaceWith(newBlock);\n    });\n\n    if (showCodeBlockCopyButton !== false) { // Default to true\n        insertCopyToClipboardButton(element);\n    }\n\n    if (markdownLinkTarget !== 'self') { // Default to 'blank'\n        element.querySelectorAll('a').forEach((link) => {\n            link.setAttribute('target', '_blank');\n        });\n    }\n\n    return element.innerHTML;\n};\n","import {StandardStreamParser} from '../../types/markdown/streamParser';\nimport {warn} from '../../utils/warn';\nimport {attachCopyClickListener} from '../copyToClipboard/attachCopyClickListener';\nimport {parseMdSnapshot} from '../snapshot/snapshotParser';\n\nconst defaultDelayInMsBeforeComplete = 2000;\nconst defaultDelayInMsBetweenBufferChecks = 8;\nconst endOfStreamChar = '\\n';\n\nconst getScheduler = (type: 'timeout' | 'animationFrame') => {\n    if (type === 'timeout') {\n        return (callback: () => void) => setTimeout(callback, 0);\n    }\n\n    return (callback: () => void) => requestAnimationFrame(callback);\n};\n\nexport const createMdStreamRenderer: StandardStreamParser = (\n    root: HTMLElement,\n    options,\n) => {\n    let streamIsComplete = false;\n\n    const letterByLetter = true;\n    const {onComplete} = options || {};\n\n    //\n    // Buffer to store the chunks of markdown to be parsed\n    // Scheduler to control the speed of the streaming animation\n    //\n    const buffer: string[] = [];\n    const scheduler = getScheduler(\n        options?.skipStreamingAnimation ? 'timeout' : 'animationFrame',\n    );\n\n    //\n    // Container for markdown being parsed and that can be updated\n    //\n    const wipContainer = document.createElement('div');\n    wipContainer.classList.add('md-in-progress');\n    root.append(wipContainer);\n\n    //\n    // Functions to commit the WIP content to the DOM\n    // And to complete the parsing\n    //\n    const commitWipContent = () => {\n        while (wipContainer.firstChild) {\n            const childToCommit = wipContainer.firstChild;\n            if (childToCommit instanceof HTMLElement) {\n                attachCopyClickListener(childToCommit);\n            }\n\n            wipContainer.before(childToCommit);\n        }\n    };\n\n    const completeParsing = () => {\n        streamIsComplete = true;\n        if (parsingInterval) {\n            clearInterval(parsingInterval);\n            parsingInterval = undefined;\n        }\n\n        commitWipContent();\n        wipContainer.remove();\n        onComplete?.();\n    };\n\n    const delayBetweenBufferChecks = (\n        !options?.skipStreamingAnimation && options?.streamingAnimationSpeed && options.streamingAnimationSpeed >= 0\n    ) ? options.streamingAnimationSpeed : (options?.skipStreamingAnimation ? 0 : defaultDelayInMsBetweenBufferChecks);\n\n    const parsingContext: {\n        timeSinceLastProcessing: number;\n        currentMarkdown: string;\n        previousHtml: string | undefined;\n    } = {\n        timeSinceLastProcessing: new Date().getTime(),\n        currentMarkdown: '',\n        previousHtml: undefined,\n    };\n\n    let parsingInterval: number | undefined = setInterval(() => {\n        const nowTime = new Date().getTime();\n        const shouldAutomaticallyCompleteAfterDelay = options?.waitTimeBeforeStreamCompletion !== 'never';\n        if (buffer.length === 0 && shouldAutomaticallyCompleteAfterDelay) {\n            const delayBeforeCompleteParsing = (typeof options?.waitTimeBeforeStreamCompletion === 'number')\n                ? options.waitTimeBeforeStreamCompletion : defaultDelayInMsBeforeComplete;\n\n            if (streamIsComplete || nowTime - parsingContext.timeSinceLastProcessing > delayBeforeCompleteParsing) {\n                completeParsing();\n            }\n\n            return;\n        }\n\n        parsingContext.timeSinceLastProcessing = nowTime;\n        const chunk = buffer.shift();\n        if (chunk === undefined || typeof chunk !== 'string') {\n            return;\n        }\n\n        scheduler(() => {\n            // We should only parse the last chunk (in it release context) instead of the whole text\n            // In order to do that, we need to distinguish between:\n            //   - We will have WIP text to being parsed, and may be incomplete (example: `# Hello, `)\n            //   - Text that is committed to the DOM and will not change (example: `# Hello World!\\n\\n`)\n\n            // Append the new chunk to the raw text and parse\n            const markdownToParse = parsingContext.currentMarkdown + chunk;\n            const parsedHtml = parseMdSnapshot(markdownToParse, options).trim();\n\n            if (typeof parsedHtml !== 'string') {\n                // Remove the last chunk if parsing failed\n                parsingContext.currentMarkdown = parsingContext.currentMarkdown.slice(0, -chunk.length);\n                warn('Markdown parsing failed');\n                return;\n            }\n\n            if (\n                parsingContext.previousHtml &&\n                parsedHtml.length > parsingContext.previousHtml.length &&\n                parsedHtml.startsWith(parsingContext.previousHtml)\n            ) {\n                // Case 1: No changes to the previous HTML — And new HTML added on top of it\n                // Which means the new chunk added new HTML content outside the last parsed markdown\n                // Which means that the last parsed markdown is complete and should be committed to the DOM\n                // Commit the last parsed content to the DOM\n\n                commitWipContent();\n\n                // Extract new HTML and insert it into WIP container\n                const currentHtml = parsedHtml.slice(parsingContext.previousHtml.length).trim();\n                wipContainer.innerHTML = options?.htmlSanitizer ? options.htmlSanitizer(currentHtml) : currentHtml;\n\n                // Focus on everything that is new\n                parsingContext.currentMarkdown = chunk;\n                parsingContext.previousHtml = undefined;\n            } else {\n                // Case 2: Changes to the previous HTML\n                // This means that new chunk goes inside previous HTML and no root level changes\n\n                // Append the new chunk to the current markdown\n                wipContainer.innerHTML = options?.htmlSanitizer ? options.htmlSanitizer(parsedHtml) : parsedHtml;\n\n                // Update the current markdown and previous HTML for the next iteration\n                parsingContext.currentMarkdown = markdownToParse;\n                parsingContext.previousHtml = parsedHtml;\n            }\n        });\n    }, delayBetweenBufferChecks) as unknown as number;\n\n    return {\n        next: (chunk: string) => {\n            if (streamIsComplete) {\n                warn('Stream is already complete. No more chunks can be added');\n                return;\n            }\n\n            if (letterByLetter) {\n                for (const char of chunk) {\n                    buffer.push(char);\n                }\n            } else {\n                buffer.push(chunk);\n            }\n        },\n        complete: () => {\n            buffer.push(endOfStreamChar);\n            streamIsComplete = true;\n        },\n        cancel: () => {\n            if (parsingInterval) {\n                clearInterval(parsingInterval);\n                parsingInterval = undefined;\n            }\n\n            streamIsComplete = true;\n            wipContainer.remove();\n        },\n        error: () => {\n            // No special handling for errors\n            // Just complete the stream\n            streamIsComplete = true;\n        },\n    };\n};\n","import {HighlighterExtension} from '../../../js/core/src';\nimport {createMdStreamRenderer} from '../../../shared/src/markdown/stream/streamParser';\nimport {SanitizerExtension} from '../../../shared/src/sanitizer/sanitizer';\nimport {CallbackFunction} from '../../../shared/src/types/callbackFunction';\n\nexport type {SnapshotParser, SnapshotParserOptions} from '../../../shared/src/types/markdown/snapshotParser';\nexport {parseMdSnapshot} from '../../../shared/src/markdown/snapshot/snapshotParser';\n\nexport type MarkdownStreamParser = {\n    next(value: string): void;\n    complete(): void;\n};\n\nexport type MarkdownStreamParserOptions = {\n    markdownLinkTarget?: 'blank' | 'self';\n    syntaxHighlighter?: HighlighterExtension;\n    htmlSanitizer?: SanitizerExtension;\n    skipStreamingAnimation?: boolean;\n    streamingAnimationSpeed?: number;\n    waitTimeBeforeStreamCompletion?: number | 'never';\n    showCodeBlockCopyButton?: boolean;\n    onComplete?: CallbackFunction;\n};\n\nexport const createMarkdownStreamParser = (\n    domElement: HTMLElement,\n    options?: MarkdownStreamParserOptions,\n): MarkdownStreamParser => {\n    const nluxMarkdownStreamRenderer = createMdStreamRenderer(\n        domElement,\n        {\n            syntaxHighlighter: options?.syntaxHighlighter,\n            htmlSanitizer: options?.htmlSanitizer,\n            markdownLinkTarget: options?.markdownLinkTarget,\n            showCodeBlockCopyButton: options?.showCodeBlockCopyButton,\n            skipStreamingAnimation: options?.skipStreamingAnimation,\n            streamingAnimationSpeed: options?.streamingAnimationSpeed,\n            waitTimeBeforeStreamCompletion: options?.waitTimeBeforeStreamCompletion,\n            onComplete: options?.onComplete,\n        },\n    );\n\n    return {\n        next(value: string) {\n            nluxMarkdownStreamRenderer.next(value);\n        },\n        complete() {\n            nluxMarkdownStreamRenderer.complete();\n        },\n    };\n};\n"],"names":["__publicField","escape","text","args","ret","tokens","src","options","newHtml"],"mappings":"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"}