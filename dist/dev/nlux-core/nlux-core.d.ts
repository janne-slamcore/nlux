/**
 * A single item in the conversation.
 * This can be a message from the user, the assistant, or a system message.
 *
 * - `role: 'assistant'`: A message from the assistant (an AI response).
 *    The message type is generic and should match the generic type `AiMsg` used across the component.
 *    The `serverResponse` field is optional and can be used to store the full response received from the server.
 *
 *  - `role: 'user'`: A message from the user.
 *    This is typically a string representing the prompt typed by the user.
 *
 *  - `role: 'system'`: A system message.
 *     This message is not displayed in the UI, but it will be used to when sending the conversation history to the AI.
 */
type ChatItem$1<AiMsg = string> = {
    role: 'assistant';
    message: AiMsg;
    serverResponse?: string | object | undefined;
} | {
    role: 'user';
    message: string;
} | {
    role: 'system';
    message: string;
};

/**
 * Additional data sent to the adapter when a message is sent.
 */
type ChatAdapterExtras$1<AiMsg = string> = {
    /**
     * This attribute contains the properties used with the AiChat component.
     */
    aiChatProps: AiChatPropsInEvents<AiMsg>;
    /**
     * This attribute contains the conversation history.
     * It's only included if the `conversationOptions.historyPayloadSize` is set to a positive number or 'all'.
     */
    conversationHistory?: ChatItem$1<AiMsg>[];
    /**
     * This attribute contains the unique identifier of the context instance.
     * It's only included if a context instance is used with the AiChat component.
     * This can be used to send the context ID to the API and get a response that is specific to the context instance.
     */
    contextId?: string;
    /**
     * This contains the headers that implementers can use to send additional data such as authentication headers.
     */
    headers?: Record<string, string>;
};

/**
 * This type is used to indicate the mode in which the adapter should request data from the API.
 */
type DataTransferMode$1 = 'stream' | 'batch';
/**
 * The type for the function used to submit a message to the API in stream mode.
 *
 * @param {string} message
 * @param {StreamingAdapterObserver} observer
 * @param {ChatAdapterExtras} extras
 */
type StreamSend<AiMsg = string> = (message: string, observer: StreamingAdapterObserver$1<AiMsg>, extras: ChatAdapterExtras$1<AiMsg>) => void;
/**
 * The type for the function used to submit a message to the API in batch mode.
 * It should return a promise that resolves to the response from the API.
 *
 * @param `string` message
 * @param `ChatAdapterExtras` extras
 * @returns Promise<string>
 */
type BatchSend<AiMsg = string> = (message: string, extras: ChatAdapterExtras$1<AiMsg>) => Promise<AiMsg>;
/**
 * This interface exposes methods that should be implemented by any chat adapter to connect the AiChat component
 * to any API or AI backend. Chat adapters can be used to request data from the API in batch mode or stream mode.
 *
 * The difference between this and the `AssistAdapter` interface is that this adapter can only return a text response
 * to be displayed to the user. It cannot return a task to be executed by the client. If you are using the `AiChat`
 * component in co-pilot mode, you should use the `AssistAdapter` interface instead.
 */
interface ChatAdapter<AiMsg = string> {
    /**
     * This method should be implemented by any adapter that wants to request data from the API in batch mode.
     * It should return a promise that resolves to the response from the API.
     * Either this method or `streamText` (or both) should be implemented by any adapter.
     *
     * @param `string` message
     * @param `ChatAdapterExtras` extras
     * @returns Promise<string>
     */
    batchText?: BatchSend<AiMsg>;
    /**
     * This method should be implemented by any adapter to be used with nlux.
     * Either this method or `batchText` (or both) should be implemented by any adapter.
     *
     * @param {string} message
     * @param {StreamingAdapterObserver} observer
     * @param {ChatAdapterExtras} extras
     */
    streamText?: StreamSend<AiMsg>;
}
/**
 * This interface is used to capture the stream of data being generated by the API and send it to the AiChat
 * user interface as it's being generated.
 */
interface StreamingAdapterObserver$1<ChunkType = string> {
    /**
     * This method should be called by the adapter when it has completed sending data to the AiChat user interface.
     * This will result in the AiChat component removing the loading indicator and resetting the conversation
     * text input.
     */
    complete(): void;
    /**
     * This method should be called by the adapter when it has an error to send to the AiChat user interface.
     * This will result in the AiChat component displaying an error message to the user, resetting the
     * conversation text input, removing the loading indicator, removing the message sent from the conversation.
     *
     * The error will be logged to the console, but it will not be displayed to the user. A generic error message
     * will be displayed to the user instead.
     *
     * @param {Error} error
     */
    error(error: Error): void;
    /**
     * This method should be called by the adapter when it has new data to send to the AiChat user interface.
     * @param {ChunkType} chunk being sent as part of the stream.
     */
    next(chunk: ChunkType): void;
}

/**
 * This type is used to indicate the mode in which the adapter should request data from the API.
 */
type DataTransferMode = 'stream' | 'batch';
/**
 * This interface is used to capture the stream of data being generated by the API and send it to the AiChat
 * user interface as it's being generated.
 */
interface StreamingAdapterObserver<ChunkType = string> {
    /**
     * This method should be called by the adapter when it has completed sending data to the AiChat user interface.
     * This will result in the AiChat component removing the loading indicator and resetting the conversation
     * text input.
     */
    complete(): void;
    /**
     * This method should be called by the adapter when it has an error to send to the AiChat user interface.
     * This will result in the AiChat component displaying an error message to the user, resetting the
     * conversation text input, removing the loading indicator, removing the message sent from the conversation.
     *
     * The error will be logged to the console, but it will not be displayed to the user. A generic error message
     * will be displayed to the user instead.
     *
     * @param {Error} error
     */
    error(error: Error): void;
    /**
     * This method should be called by the adapter when it has new data to send to the AiChat user interface.
     * @param {ChunkType} chunk being sent as part of the stream.
     */
    next(chunk: ChunkType): void;
}

/**
 * This type represents the information that the AiChat needs to know about an adapter.
 * It is used to determine which adapters are available and what capabilities they have.
 */
type StandardAdapterInfo$1 = Readonly<{
    id: string;
    capabilities: Readonly<{
        chat: boolean;
        fileUpload: boolean;
        textToSpeech: boolean;
        speechToText: boolean;
    }>;
}>;

/**
 * This interface is used by standard adapters provided by nlux to communicate with the AiChat component.
 */
interface StandardChatAdapter$1<AiMsg = string> {
    batchText(message: string, extras: ChatAdapterExtras$1<AiMsg>): Promise<string | object | undefined>;
    get dataTransferMode(): DataTransferMode;
    get id(): string;
    get info(): StandardAdapterInfo$1;
    preProcessAiBatchedMessage(message: string | object | undefined, extras: ChatAdapterExtras$1<AiMsg>): AiMsg | undefined;
    preProcessAiStreamedChunk(chunk: string | object | undefined, extras: ChatAdapterExtras$1<AiMsg>): AiMsg | undefined;
    streamText(message: string, observer: StreamingAdapterObserver<string | object | undefined>, extras: ChatAdapterExtras$1<AiMsg>): void;
}

/**
 * The base interface for creating a new instance of a StandardChatAdapter.
 * Adapter builders can extend this interface to add additional methods for configuration.
 */
interface ChatAdapterBuilder<AiMsg> {
    create(): StandardChatAdapter$1<AiMsg>;
}

/**
 * This interface is used by standard adapters provided by nlux to communicate with the AiChat component.
 */
interface StandardChatAdapter<AiMsg = string> {
    batchText(message: string, extras: ChatAdapterExtras$1<AiMsg>): Promise<string | object | undefined>;
    get dataTransferMode(): DataTransferMode;
    get id(): string;
    get info(): StandardAdapterInfo$1;
    preProcessAiBatchedMessage(message: string | object | undefined, extras: ChatAdapterExtras$1<AiMsg>): AiMsg | undefined;
    preProcessAiStreamedChunk(chunk: string | object | undefined, extras: ChatAdapterExtras$1<AiMsg>): AiMsg | undefined;
    streamText(message: string, observer: StreamingAdapterObserver<string | object | undefined>, extras: ChatAdapterExtras$1<AiMsg>): void;
}

/**
 * A single item in the conversation.
 * This can be a message from the user, the assistant, or a system message.
 *
 * - `role: 'assistant'`: A message from the assistant (an AI response).
 *    The message type is generic and should match the generic type `AiMsg` used across the component.
 *    The `serverResponse` field is optional and can be used to store the full response received from the server.
 *
 *  - `role: 'user'`: A message from the user.
 *    This is typically a string representing the prompt typed by the user.
 *
 *  - `role: 'system'`: A system message.
 *     This message is not displayed in the UI, but it will be used to when sending the conversation history to the AI.
 */
type ChatItem<AiMsg = string> = {
    role: 'assistant';
    message: AiMsg;
    serverResponse?: string | object | undefined;
} | {
    role: 'user';
    message: string;
} | {
    role: 'system';
    message: string;
};

interface ComposerOptions {
    /**
     * Indicates whether the prompt input field should be focused when the prompt is shown.
     * @default false
     */
    autoFocus?: boolean;
    /**
     * This will override the disabled state of the submit button when the composer is in 'typing' status.
     * It will not have any impact in the composer 'submitting-prompt' and 'waiting' statuses, as the submit button
     * is always disabled in these statuses.
     *
     * @default: Submit button is only enabled when the message is not empty.
     */
    disableSubmitButton?: boolean;
    /**
     * Indicates whether the stop button should be hidden.
     *
     * @default false
     */
    hideStopButton?: boolean;
    /**
     * The placeholder message to be displayed in the prompt input field when empty.
     */
    placeholder?: string;
    /**
     * The shortcut to submit the prompt message.
     *
     * - `Enter`: The user can submit the prompt message by pressing the `Enter` key. In order to add a new line, the
     * user can press `Shift + Enter`.
     * - `CommandEnter`: When this is used, the user can submit the prompt message by pressing `Ctrl + Enter` on
     * Windows/Linux or `Cmd + Enter` on macOS. In order to add a new line, the user can press `Enter`.
     *
     * @default 'Enter'
     */
    submitShortcut?: 'Enter' | 'CommandEnter';
}

/**
 * This represents a single item displayed in the chat UI while the conversation has not started yet.
 *
 */
type ConversationStarter = {
    /**
     * The prompt to type in the composer input and submit to start the conversation.
     */
    prompt: string;
    /**
     * An optional label to display inside the conversation starter option button.
     */
    label?: string;
    /**
     * An optional icon to display inside the conversation starter option button.
     * This could either be a URL to an image or an HTML element.
     */
    icon?: string | Readonly<HTMLElement>;
};

type HistoryPayloadSize = number | 'max';
type ConversationLayout = 'bubbles' | 'list';
interface ConversationOptions {
    /**
     * Indicates whether the conversation should be scrolled to the bottom when a new message is added.
     *
     * @default true
     */
    autoScroll?: boolean;
    /**
     * Suggested prompts to display in the UI to help the user start a conversation.
     * Conversation starters are only displayed when the conversation is empty, and no conversation history is present.
     */
    conversationStarters?: ConversationStarter[];
    /**
     * Indicates the number of messages from conversation history that should be sent to the backend with each message.
     * For custom adapters, the history will be available as part of `extras.conversationHistory` attribute.
     * For standard adapters, the history will be automatically handled by the adapter.
     *
     * By default, the entire conversation history is sent with each message.
     * Set to `0` to disable sending conversation history with each message.
     * Or set to a positive integer to send a specific number of messages.
     *
     * @default 'max'
     */
    historyPayloadSize?: HistoryPayloadSize;
    /**
     * Indicates how items in the conversation should be displayed.
     *
     * - `list`: Chat items are displayed as a list with the AI responses underneath each user message.
     * - `bubbles`: Items are displayed as chat bubbles with the prompts on the right and the AI messages on the left.
     *
     * @default 'bubbles'
     */
    layout?: ConversationLayout;
    /**
     * Indicates whether the welcome message should be displayed when no conversation history is provided.
     * The welcome message consists of:
     * - The assistant's name and avatar
     * - The assistant's tagline as configured in the `personaOptions`
     *
     * When no assistant persona is provided, the welcome message will be the NLUX logo.
     */
    showWelcomeMessage?: boolean;
}

type DisplayOptions = {
    /**
     * The theme ID to use.
     * This should be the ID of a theme that has been loaded into the page.
     */
    themeId?: string;
    /**
     * Color scheme for the component.
     * This can be 'light', 'dark', or 'auto'.
     *
     * If 'auto' is used, the component will automatically switch between 'light' and 'dark' based on the user's
     * operating system preferences (if it can be detected), otherwise it will default to 'light'.
     *
     * @default 'auto'
     */
    colorScheme?: 'light' | 'dark' | 'auto';
    /**
     * The width of the component.
     */
    width?: number | string;
    /**
     * The height of the component.
     */
    height?: number | string;
};

/**
 * A type representing a function to use as HTML sanitizer.
 * This type can be passed to markdown parser, to be used to sanitize generated
 * HTML before appending it to the document.
 */
type SanitizerExtension = (html: string) => string;

type Highlighter = (input: string, language: string) => string;
type HighlighterColorMode = 'dark' | 'light';
type CreateHighlighterOptions = {
    language?: string;
    colorMode?: HighlighterColorMode;
};
interface HighlighterExtension {
    createHighlighter(options?: CreateHighlighterOptions): Highlighter;
    highlightingClass(language?: string): string;
}

/**
 * Props for the custom function that renders a message sent by the server in batch mode.
 * @template AiMsg The type of the message received from the AI. Defaults to string for standard NLUX adapters.
 *
 * @property {string} uid The unique identifier of the message.
 * @property {'batch'} dataTransferMode The data transfer mode used by the adapter.
 * @property {'complete'} status The status of the message.
 *
 * @property {AiMsg} content The content of the message. The content is a single message.
 * @property {unknown} serverResponse The raw server response. The server response is a single object or string
 * representing the raw response received from the server.
 */
type ResponseRendererProps<AiMsg> = {
    uid: string;
    dataTransferMode: 'stream' | 'batch';
    status: 'streaming' | 'complete';
    content: [AiMsg];
    serverResponse: unknown[];
};
type ResponseRenderer<AiMsg> = (props: ResponseRendererProps<AiMsg>) => HTMLElement | null;
type PromptRendererProps = {
    uid: string;
    prompt: string;
};
type PromptRenderer = (props: PromptRendererProps) => HTMLElement | null;
type MessageOptions<AiMsg = string> = {
    /**
     * Highlighter extension for code blocks inside messages.
     */
    syntaxHighlighter?: HighlighterExtension;
    /**
     * Custom function to sanitize the HTML content of the messages. This function is called before any HTML content
     * is rendered in the chat.
     *
     * @param {string} html
     * @returns {string}
     */
    htmlSanitizer?: SanitizerExtension;
    /**
     * Indicates the target of the links in the markdown messages.
     * - 'blank': Open links in a new tab.
     * - 'self': Open links in the same tab.
     *
     * @default 'blank'
     */
    markdownLinkTarget?: 'blank' | 'self';
    /**
     * Indicates whether the copy button should be shown for code blocks.
     *
     * @default true
     */
    showCodeBlockCopyButton?: boolean;
    /**
     * Indicates whether the streaming animation should be skipped.
     *
     * @default false
     */
    skipStreamingAnimation?: boolean;
    /**
     * The interval in milliseconds at which new characters are added when a message is being generated and
     * streamed to the user.
     *
     * @default 10
     */
    streamingAnimationSpeed?: number;
    /**
     * In streaming data transfer mode, this represents the wait time in milliseconds after last chunk of data
     * is received before marking the streaming as complete. This can be used to prevent the streaming from being
     * marked as complete too early.
     *
     * If set to 'never', the streaming will never be automatically be marked as complete. It will be up to the
     * adapter to manually mark the streaming as complete by calling the `observer.complete()` method.
     *
     * @default 2000
     */
    waitTimeBeforeStreamCompletion?: number | 'never';
    /**
     * Custom function to render the message received from the AI.
     */
    responseRenderer?: ResponseRenderer<AiMsg>;
    /**
     * Custom function to render the message sent by the user.
     */
    promptRenderer?: PromptRenderer;
    /**
     * Indicates whether the user should be able to edit the message after sending it.
     * Editing a message will replace the original message and will remove all subsequent messages in the conversation.
     *
     * @default false
     */
    editableUserMessages?: boolean;
};

interface AssistantPersona {
    avatar: string | Readonly<HTMLElement>;
    name: string;
    tagline?: string;
}
interface UserPersona {
    avatar: string | Readonly<HTMLElement>;
    name: string;
}
interface PersonaOptions {
    assistant?: AssistantPersona;
    user?: UserPersona;
}

declare const NLErrors: {
    'data-transfer-mode-not-supported': string;
    'no-data-transfer-mode-supported': string;
    'connection-error': string;
    'invalid-credentials': string;
    'invalid-api-key': string;
    'http-server-side-error': string;
    'http-client-side-error': string;
    'failed-to-load-content': string;
    'failed-to-stream-content': string;
    'failed-to-stream-server-component': string;
    'failed-to-render-content': string;
};
type NLErrorId = keyof typeof NLErrors;

/**
 * These are the props that are used internally by the AiChat component.
 */
type AiChatInternalProps<AiMsg> = {
    adapter: ChatAdapter<AiMsg> | StandardChatAdapter<AiMsg>;
    className?: string;
    events?: EventsConfig<AiMsg>;
    initialConversation?: ChatItem<AiMsg>[];
    displayOptions: DisplayOptions;
    personaOptions: PersonaOptions;
    composerOptions: ComposerOptions;
    conversationOptions: ConversationOptions;
    messageOptions: MessageOptions<AiMsg>;
};
/**
 * These are the props that are exposed to the user of the AiChat component.
 */
type AiChatProps<AiMsg = string> = {
    adapter: ChatAdapter<AiMsg> | StandardChatAdapter<AiMsg>;
    className?: string;
    events?: EventsConfig<AiMsg>;
    initialConversation?: ChatItem<AiMsg>[];
    composerOptions?: ComposerOptions;
    conversationOptions?: ConversationOptions;
    messageOptions?: MessageOptions<AiMsg>;
    personaOptions?: PersonaOptions;
    displayOptions?: DisplayOptions;
};
/**
 * When sending props to event callbacks, we exclude the adapter and events properties.
 * This is because they are not serializable and because the events are already being called.
 */
type AiChatPropsInEvents<AiMsg = string> = Omit<AiChatProps<AiMsg>, 'adapter' | 'events'>;
/**
 * This type represents the props that can be updated on the AiChat component, after it has been initialized.
 * It excludes the initialConversation property because it's only used during initialization and cannot be updated.
 */
type UpdatableAiChatProps<AiMsg> = Partial<Omit<AiChatProps<AiMsg>, 'initialConversation'>>;

type MessageSentEventDetails = {
    uid: string;
    message: string;
};
type MessageStreamStartedEventDetails = {
    uid: string;
};
type ServerComponentStreamStartedEventDetails = {
    uid: string;
};
type ServerComponentRenderedEventDetails = {
    uid: string;
};
type MessageRenderedEventDetails<AiMsg = string> = {
    uid: string;
    message?: AiMsg;
};
type MessageReceivedEventDetails<AiMsg = string> = {
    uid: string;
    message: AiMsg;
};
type ErrorEventDetails = {
    errorId: NLErrorId;
    message: string;
    errorObject?: Error;
};
type ReadyEventDetails<AiMsg = string> = {
    aiChatProps: AiChatPropsInEvents<AiMsg>;
};
type PreDestroyEventDetails<AiMsg = string> = {
    aiChatProps: AiChatPropsInEvents<AiMsg>;
    conversationHistory: Readonly<ChatItem<AiMsg>[]>;
};
/**
 * The callback for when an error event is emitted.
 *
 * @param errorDetails The details of the error event such as the error message and the error id.
 */
type ErrorCallback = (errorDetails: ErrorEventDetails) => void;
/**
 * The callback for when a message is sent.
 * This is called when the chat component sends the message to the adapter.
 *
 * @param message The message that was sent.
 */
type MessageSentCallback = (event: MessageSentEventDetails) => void;
/**
 * The callback for when a response starts streaming from the adapter.
 * This is called when the chat component receives the first part of the response from the adapter.
 * This does not mean that the message has been rendered yet. You should use the messageRendered event
 * if you want to know when the message has been rendered.
 *
 * @param event The event details such as the uid of the message.
 */
type MessageStreamStartedCallback = (event: MessageStreamStartedEventDetails) => void;
/**
 * The callback for when a server component stream starts.
 * This is used with React Server Component adapters to trigger an event when the component is about
 * to get mounted.
 */
type ServerComponentStreamStartedCallback = (event: ServerComponentStreamStartedEventDetails) => void;
/**
 * The callback for when a server component is loaded and successfully rendered on the screen.
 *
 * @param event The event details such as the uid of the message.
 */
type ServerComponentRenderedCallback = (event: ServerComponentRenderedEventDetails) => void;
/**
 * The callback for when a message is received.
 * This is called when the chat component receives the full response from the adapter.
 * This does not mean that the message has been rendered yet. You should use the messageRendered
 * event if you want to know when the message has been rendered.
 *
 * @param event The event details such as the uid of the message and the message content.
 */
type MessageReceivedCallback<AiMsg = string> = (event: MessageReceivedEventDetails<AiMsg>) => void;
/**
 * The callback for when a message is fully rendered on the screen.
 * This event is only relevant when the user is using the NLUX markdown renderer.
 * If the user is using a custom renderer and directly accessing the props.content property to render the message,
 * this event will not be relevant.
 *
 * @param event The event details such as the uid of the message.
 */
type MessageRenderedCallback<AiMsg = string> = (event: MessageRenderedEventDetails<AiMsg>) => void;
/**
 * The callback for when the chat component is ready.
 * This is called when the chat component is fully initialized and ready to be used.
 *
 * @param readyDetails The details of the ready event such as the AiChatProps used to initialize the chat component.
 */
type ReadyCallback<AiMsg = string> = (readyDetails: ReadyEventDetails<AiMsg>) => void;
/**
 * The callback for when the chat component is about to be destroyed.
 * This is called when the chat component is about to be destroyed and unmounted from the DOM.
 *
 * @param preDestroyDetails The details of the pre-destroy event such as the AiChatProps used to initialize the chat
 * component and the conversation history.
 */
type PreDestroyCallback<AiMsg = string> = (preDestroyDetails: PreDestroyEventDetails<AiMsg>) => void;
type EventsMap<AiMsg> = {
    ready: ReadyCallback<AiMsg>;
    preDestroy: PreDestroyCallback<AiMsg>;
    messageSent: MessageSentCallback;
    messageStreamStarted: MessageStreamStartedCallback;
    messageReceived: MessageReceivedCallback<AiMsg>;
    messageRendered: MessageRenderedCallback<AiMsg>;
    serverComponentStreamStarted: ServerComponentStreamStartedCallback;
    serverComponentRendered: ServerComponentRenderedCallback;
    error: ErrorCallback;
};
type EventName = keyof EventsMap<unknown>;
type EventCallback<AiMsg = string> = EventsMap<AiMsg>[EventName];
type EventsConfig<AiMsg = string> = Partial<EventsMap<AiMsg>>;

/**
 * The status of the AiChat component.
 * - `idle`: The component has not been mounted yet.
 * - `mounted`: The component is currently mounted and active. It can be visible or hidden.
 * - `unmounted`: The component has been unmounted and destroyed and cannot be used anymore.
 */
type AiChatStatus = 'idle' | 'mounted' | 'unmounted';
/**
 * The main interface representing AiChat component.
 * It provides methods to instantiate, mount, and unmount the component, and listen to its events.
 */
interface IAiChat<AiMsg> {
    /**
     * Hides the chat component.
     * This does not unmount the component. It will only hide the chat component from the view.
     */
    hide(): void;
    /**
     * Mounts the chat component to the given root element.
     *
     * @param {HTMLElement} rootElement
     */
    mount(rootElement: HTMLElement): void;
    /**
     * Adds an event listener to the chat component.
     * The callback will be called when the event is emitted, with the expected event details.
     *
     * @param {EventName} event The name of the event to listen to.
     * @param {EventsMap[EventName]} callback The callback to be called, that should match the event type.
     * @returns {IAiChat}
     */
    on(event: EventName, callback: EventsMap<AiMsg>[EventName]): IAiChat<AiMsg>;
    /**
     * Removes all event listeners from the chat component for a specific event.
     *
     * @param {EventName} event
     */
    removeAllEventListeners(event: EventName): void;
    /**
     * Removes the given event listener for the specified event.
     *
     * @param {EventName} event The name of the event to remove the listener from.
     * @param {EventsMap[EventName]} callback The callback to be removed.
     */
    removeEventListener(event: EventName, callback: EventCallback<AiMsg>): void;
    /**
     * Shows the chat component.
     * This method expects the chat component to be mounted.
     */
    show(): void;
    /**
     * Returns true if the chat component is mounted.
     */
    get status(): AiChatStatus;
    /**
     * Unmounts the chat component.
     * This will remove the chat component from the view and clean up its resources.
     * After unmounting, the chat component cannot be mounted again as all its resources, options, event listeners, and
     * adapters will be removed. You should create a new chat component if you want to use it again.
     */
    unmount(): void;
    /**
     * Updates the properties of the chat component. This method expects the chat component to be mounted.
     * The properties will be updated and the relevant parts of the chat component will be re-rendered.
     *
     * @param {UpdatableAiChatProps} props The properties to be updated.
     */
    updateProps(props: UpdatableAiChatProps<AiMsg>): void;
    /**
     * Enabled providing an adapter to the chat component.
     * The adapter will be used to send and receive messages from the chat backend.
     * This method should be called before mounting the chat component, and it should be called only once.
     *
     * @param {adapter: ChatAdapter | StandardChatAdapter | ChatAdapterBuilder} adapter The builder for the chat
     *     adapter.
     */
    withAdapter(adapter: ChatAdapter<AiMsg> | StandardChatAdapter<AiMsg> | ChatAdapterBuilder<AiMsg>): IAiChat<AiMsg>;
    /**
     * Enables providing a class name to the chat component.
     * The class name will be added to the root element of the chat component.
     * This method should be called before mounting the chat component, and it should be called only once.
     *
     * @param {string} className The class name to be added to the chat component.
     */
    withClassName(className: string): IAiChat<AiMsg>;
    /**
     * Enables providing composer options to the chat component.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {ComposerOptions} composerOptions The composer options to be used.
     */
    withComposerOptions(composerOptions: ComposerOptions): IAiChat<AiMsg>;
    /**
     * The conversation options will be used to configure the conversation behavior and display.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {ConversationOptions} conversationOptions The conversation options to be used.
     */
    withConversationOptions(conversationOptions: ConversationOptions): IAiChat<AiMsg>;
    /**
     * Enables providing display options to the chat component. The display options will be used to configure the
     * layout of the chat component. When no display options are provided, the default display options will be used.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {DisplayOptions} displayOptions The display options to be used.
     */
    withDisplayOptions(displayOptions: DisplayOptions): IAiChat<AiMsg>;
    /**
     * Enables providing an initial conversation to the chat component.
     * The initial conversation will be used to populate the chat component with a conversation history.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {ChatItem[]} initialConversation
     * @returns {IAiChat}
     */
    withInitialConversation(initialConversation: ChatItem<AiMsg>[]): IAiChat<AiMsg>;
    /**
     * Enables providing message options to the chat component.
     * The message options will be used to configure the behavior and the
     * display of the messages inside the chat component.
     *
     * @param {MessageOptions<AiMsg>} messageOptions
     * @returns {IAiChat<AiMsg>}
     */
    withMessageOptions(messageOptions: MessageOptions<AiMsg>): IAiChat<AiMsg>;
    /**
     * Enables providing persona options to the chat component. The persona options will be used to configure
     * the assistant and user personas in the chat component.
     * This method can be called before mounting the chat component, and it can be called only once.
     *
     * @param {PersonaOptions} personaOptions The persona options to be used.
     */
    withPersonaOptions(personaOptions: PersonaOptions): IAiChat<AiMsg>;
}

declare class AiChat<AiMsg = string> implements IAiChat<AiMsg> {
    protected theAdapter: ChatAdapter<AiMsg> | StandardChatAdapter<AiMsg> | null;
    protected theAdapterBuilder: ChatAdapterBuilder<AiMsg> | null;
    protected theAdapterType: 'builder' | 'instance' | null;
    protected theClassName: string | null;
    protected theComposerOptions: ComposerOptions | null;
    protected theConversationOptions: ConversationOptions | null;
    protected theDisplayOptions: DisplayOptions | null;
    protected theInitialConversation: ChatItem<AiMsg>[] | null;
    protected theMessageOptions: MessageOptions<AiMsg> | null;
    protected thePersonasOptions: PersonaOptions | null;
    private aiChatStatus;
    private controller;
    private unregisteredEventListeners;
    get status(): AiChatStatus;
    private get isIdle();
    hide(): void;
    mount(rootElement: HTMLElement): void;
    on(event: EventName, callback: EventsMap<AiMsg>[EventName]): this;
    removeAllEventListeners(event: EventName): void;
    removeEventListener(event: EventName, callback: EventCallback<AiMsg>): void;
    show(): void;
    unmount(): void;
    updateProps(props: UpdatableAiChatProps<AiMsg>): void;
    withAdapter(adapter: ChatAdapter<AiMsg> | StandardChatAdapter<AiMsg> | ChatAdapterBuilder<AiMsg>): this;
    withClassName(className: string): this;
    withComposerOptions(composerOptions: ComposerOptions): this;
    withConversationOptions(conversationOptions: ConversationOptions): this;
    withDisplayOptions(displayOptions: DisplayOptions): this;
    withInitialConversation(initialConversation: ChatItem<AiMsg>[]): this;
    withMessageOptions(messageOptions: MessageOptions<AiMsg>): this;
    withPersonaOptions(personaOptions: PersonaOptions): this;
    private clearEventListeners;
}

interface IObserver<DataType> {
    complete?(): void;
    error?(error: Error): void;
    next(value: DataType): void;
}

declare class Observable<DataType> {
    private buffer;
    private errorReceived;
    private isCompleted;
    private readonly isReplayObservable;
    private subscribers;
    constructor({ replay }?: {
        replay?: boolean;
    });
    complete(): void;
    error(error: Error): void;
    next(value: DataType): void;
    reset(): void;
    subscribe(observer: IObserver<DataType>): {
        unsubscribe: () => void;
    };
    unsubscribe(observer: IObserver<DataType>): void;
    private sendBufferToObserver;
}

type OutputFormat = 'text' | 'audio' | 'markdown' | 'html' | 'image' | 'video' | 'file';
type InputFormat = 'text';
type AdapterEncodeFunction<OutboundPayload> = (input: string) => Promise<OutboundPayload>;
type AdapterDecodeFunction<InboundPayload> = <AiMsg>(output: InboundPayload) => Promise<AiMsg | undefined>;
/**
 * This type represents the information that the AiChat needs to know about an adapter.
 * It is used to determine which adapters are available and what capabilities they have.
 */
type StandardAdapterInfo = Readonly<{
    id: string;
    capabilities: Readonly<{
        chat: boolean;
        fileUpload: boolean;
        textToSpeech: boolean;
        speechToText: boolean;
    }>;
}>;

/**
 * Additional data sent to the adapter when a message is sent.
 */
type ChatAdapterExtras<AiMsg = string> = {
    /**
     * This attribute contains the properties used with the AiChat component.
     */
    aiChatProps: AiChatPropsInEvents<AiMsg>;
    /**
     * This attribute contains the conversation history.
     * It's only included if the `conversationOptions.historyPayloadSize` is set to a positive number or 'all'.
     */
    conversationHistory?: ChatItem$1<AiMsg>[];
    /**
     * This attribute contains the unique identifier of the context instance.
     * It's only included if a context instance is used with the AiChat component.
     * This can be used to send the context ID to the API and get a response that is specific to the context instance.
     */
    contextId?: string;
    /**
     * This contains the headers that implementers can use to send additional data such as authentication headers.
     */
    headers?: Record<string, string>;
};

/**
 * This type represents the result of an assist request.
 *
 * If the request was successful, the `success` property will be `true` and the `response` property will contain the
 * text response to be displayed to the user. In addition, when the `task` property is present, it will contain the
 * details of the task to be executed by the client.
 *
 * If the request was not successful, the `success` property will be `false` and the `error` property will contain the
 * error message to be displayed to the user.
 */
type AssistResult$1 = {
    success: true;
    response: string;
    task?: {
        id: string;
        parameters: string[];
    };
} | {
    success: false;
    error: string;
};
/**
 * This interface exposes methods that should be implemented by adapters used when the AiChat is in co-pilot mode.
 * The difference between this and the `ChatAdapter` interface is that this adapter can return a task to be executed
 * by the client in addition to the text response to be displayed.
 *
 * Assist adapters can only be used in batch mode, and the response cannot be streamed.
 */
interface AssistAdapter$1 {
    /**
     * This method should be implemented by any adapter that wants to request data from the API in batch mode.
     * It should return a promise that resolves to the response from the API.
     * Either this method or `streamText` (or both) should be implemented by any adapter.
     *
     * @param `string` message
     * @param `ChatAdapterExtras` extras
     * @returns Promise<string>
     */
    assist?: (message: string, extras: ChatAdapterExtras$1<string>) => Promise<AssistResult$1>;
}

/**
 * This type represents the result of an assist request.
 *
 * If the request was successful, the `success` property will be `true` and the `response` property will contain the
 * text response to be displayed to the user. In addition, when the `task` property is present, it will contain the
 * details of the task to be executed by the client.
 *
 * If the request was not successful, the `success` property will be `false` and the `error` property will contain the
 * error message to be displayed to the user.
 */
type AssistResult = {
    success: true;
    response: string;
    task?: {
        id: string;
        parameters: string[];
    };
} | {
    success: false;
    error: string;
};
/**
 * This interface exposes methods that should be implemented by adapters used when the AiChat is in co-pilot mode.
 * The difference between this and the `ChatAdapter` interface is that this adapter can return a task to be executed
 * by the client in addition to the text response to be displayed.
 *
 * Assist adapters can only be used in batch mode, and the response cannot be streamed.
 */
interface AssistAdapter {
    /**
     * This method should be implemented by any adapter that wants to request data from the API in batch mode.
     * It should return a promise that resolves to the response from the API.
     * Either this method or `streamText` (or both) should be implemented by any adapter.
     *
     * @param `string` message
     * @param `ChatAdapterExtras` extras
     * @returns Promise<string>
     */
    assist?: (message: string, extras: ChatAdapterExtras$1<string>) => Promise<AssistResult>;
}

/**
 * The base interface for creating a new instance of a StandardChatAdapter.
 * Adapter builders can extend this interface to add additional methods for configuration.
 */
interface AssistAdapterBuilder {
    /**
     * Create a new instance of an AssistAdapter.
     */
    create(): AssistAdapter;
}

type StreamParser = (root: HTMLElement, syntaxHighlighter?: HighlighterExtension) => IObserver<string>;
type StandardStreamParserOutput = {
    next(value: string): void;
    complete(): void;
    cancel(): void;
    error(error: Error): void;
};
type StandardStreamParser = (root: HTMLElement, options?: {
    syntaxHighlighter?: HighlighterExtension;
    htmlSanitizer?: SanitizerExtension;
    markdownLinkTarget?: 'blank' | 'self';
    showCodeBlockCopyButton?: boolean;
    skipStreamingAnimation?: boolean;
    streamingAnimationSpeed?: number;
    waitTimeBeforeStreamCompletion?: number | 'never';
    onComplete?: () => void;
}) => StandardStreamParserOutput;

type ContextItemDataType$1 = number | string | boolean | null | ContextObject$1 | ContextItemDataType$1[];
type ContextObject$1 = {
    [key: string]: ContextItemDataType$1;
};
type ContextItem$1 = {
    value: ContextItemDataType$1;
    description: string;
};
type ContextItems$1 = Record<string, ContextItem$1>;
type ContextTask$1 = {
    description: string;
    paramDescriptions: string[];
};
type ContextTasks$1 = Record<string, ContextTask$1>;

type InitializeContextResult$1 = {
    success: true;
    contextId: string;
} | {
    success: false;
    error: string;
};
type DestroyContextResult$1 = {
    success: true;
} | {
    success: false;
    error: string;
};
type FlushContextResult$1 = {
    success: true;
} | {
    success: false;
    error: string;
};
type RunTaskResult$1 = {
    success: true;
    result?: unknown;
} | {
    success: false;
    error: string;
};
type ContextActionResult$1 = {
    success: true;
} | {
    success: false;
    error: string;
};
type SetContextResult$1 = {
    success: true;
    contextId: string;
} | {
    success: false;
    error: string;
};

type ContextItemDataType = number | string | boolean | null | ContextObject | ContextItemDataType[];
type ContextObject = {
    [key: string]: ContextItemDataType;
};
type ContextItem = {
    value: ContextItemDataType;
    description: string;
};
type ContextItems = Record<string, ContextItem>;
type ContextTask = {
    description: string;
    paramDescriptions: string[];
};
type ContextTasks = Record<string, ContextTask>;

/**
 * This represents a set of extra data that can be sent to the context adapter.
 * It can be used by implementations to send additional data such as authentication headers.
 */
type ContextAdapterExtras$1 = {
    /**
     * This contains the headers that implementers can use to send additional data such as authentication headers.
     */
    headers?: Record<string, string>;
};

/**
 * The context data adapter is responsible for synchronizing the context data between the frontend application
 * and the backend system. In order to build a context-aware chat experience and AI assistants, the context
 * adapter should be used.
 *
 * nlux does not set any restrictions on the context data structure or where and how the data should be stored,
 * but it expects the backend system responsible for generating the chat responses to be able to access the
 * context data as needed.
 *
 * The goal of the context this adapter is to facilitate providing the context data to the backend.
 * The following methods are expected to be implemented by the context data adapter:
 *
 * - Set context data: On initial load, the context data should be set to the initial state.
 * - Get context data: Data loaded from the backend.
 * - Update context data: Called when the context data is updated.
 * - Clear context data: When the app is closed or the user logs out, the context data should be cleared.
 */
interface ContextDataAdapter$1 {
    /**
     * Creates a new context and sets the initial context data when provided.
     * On success, the new context ID should be returned.
     *
     * @param {Object} initialData
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<SetContextResult>}
     */
    create: (initialItems?: ContextItems, extras?: ContextAdapterExtras$1) => Promise<SetContextResult$1>;
    /**
     * Deletes the context data and any registered tasks for the given context ID, and makes the context ID invalid.
     * This method should be used when the context is no longer needed.
     *
     * @param {string} contextId
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    discard: (contextId: string, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Deletes the data for the given context ID and item IDs.
     *
     * @param {string} contextId The context ID.
     * @param {string[]} itemIds The item IDs to delete.
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    removeItems: (contextId: string, itemIds: string[], extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Resets the context data for the given context ID.
     * If no new context data is not provided, the context will be emptied.
     * If new context data is provided, it will replace the existing context data.
     *
     * @param {string} contextId
     * @param {ContextItems} newData
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    resetItems: (contextId: string, newData?: ContextItems, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Updates data for the given context ID.
     *
     *
     * @param {string} contextId
     * @param {string} itemId
     * @param {Object} data
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    updateItems: (contextId: string, itemsToUpdate: Partial<ContextItems>, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
}

/**
 * The context tasks adapter is responsible for registering and unregistering tasks that can be triggered by
 * the AI assistant. The tasks are front-end specific but can be triggered by backend based on specific user
 * prompts in the AI chat. In order to build a context-aware chat experience that can also trigger front-end
 * tasks, the context tasks adapter should be used to let the backend know about the tasks that can be triggered.
 *
 * The following methods are expected to be implemented by the context tasks adapter:
 *
 * - Register task: When a new screen is loaded, or a specific state is reached, a new task can be registered.
 * - Unregister task: When the screen is closed or the state is no longer valid, the task should be unregistered.
 */
interface ContextTasksAdapter$1 {
    /**
     * Unregisters specific tasks from the given context ID, based on their task IDs.
     *
     * @param {string} contextId
     * @param {string} taskIds[]
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    removeTasks: (contextId: string, taskIds: string[], extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Resets the tasks for the given context ID.
     * If new tasks are provided, they will replace the existing tasks.
     * If no tasks are provided, all the tasks will be emptied.
     *
     * @param {string} contextId
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    resetTasks: (contextId: string, newTasks?: ContextTasks, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Updates the tasks included in the `tasks` object, for the given context ID.
     * Tasks that are not included in the `tasks` object should be left unchanged.
     * If you want to remove a task, you should use the `removeTasks` method.
     *
     * @param {string} contextId
     * @param {Partial<ContextTasks>} tasks
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    updateTasks: (contextId: string, tasks: Partial<ContextTasks>, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
}

/**
 * The context adapter context-aware chat experience and AI assistants.
 * This type provides the methods for both context data and tasks that should be implemented by adapters
 * in order to synchronize data related to the context between the frontend and the backend.
 *
 * If your chat experience does not require the execution of tasks, you can use the ContextDataAdapter type instead.
 * But if you need the LLM to execute tasks, as well as access the context data, you should use the ContextAdapter type
 * to implement both the context data and tasks.
 */
interface ContextAdapter$1 extends ContextDataAdapter$1, ContextTasksAdapter$1 {
}

/**
 * This represents a set of extra data that can be sent to the context adapter.
 * It can be used by implementations to send additional data such as authentication headers.
 */
type ContextAdapterExtras = {
    /**
     * This contains the headers that implementers can use to send additional data such as authentication headers.
     */
    headers?: Record<string, string>;
};

/**
 * The context tasks adapter is responsible for registering and unregistering tasks that can be triggered by
 * the AI assistant. The tasks are front-end specific but can be triggered by backend based on specific user
 * prompts in the AI chat. In order to build a context-aware chat experience that can also trigger front-end
 * tasks, the context tasks adapter should be used to let the backend know about the tasks that can be triggered.
 *
 * The following methods are expected to be implemented by the context tasks adapter:
 *
 * - Register task: When a new screen is loaded, or a specific state is reached, a new task can be registered.
 * - Unregister task: When the screen is closed or the state is no longer valid, the task should be unregistered.
 */
interface ContextTasksAdapter {
    /**
     * Unregisters specific tasks from the given context ID, based on their task IDs.
     *
     * @param {string} contextId
     * @param {string} taskIds[]
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    removeTasks: (contextId: string, taskIds: string[], extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Resets the tasks for the given context ID.
     * If new tasks are provided, they will replace the existing tasks.
     * If no tasks are provided, all the tasks will be emptied.
     *
     * @param {string} contextId
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    resetTasks: (contextId: string, newTasks?: ContextTasks, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Updates the tasks included in the `tasks` object, for the given context ID.
     * Tasks that are not included in the `tasks` object should be left unchanged.
     * If you want to remove a task, you should use the `removeTasks` method.
     *
     * @param {string} contextId
     * @param {Partial<ContextTasks>} tasks
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    updateTasks: (contextId: string, tasks: Partial<ContextTasks>, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
}

/**
 * The context data adapter is responsible for synchronizing the context data between the frontend application
 * and the backend system. In order to build a context-aware chat experience and AI assistants, the context
 * adapter should be used.
 *
 * nlux does not set any restrictions on the context data structure or where and how the data should be stored,
 * but it expects the backend system responsible for generating the chat responses to be able to access the
 * context data as needed.
 *
 * The goal of the context this adapter is to facilitate providing the context data to the backend.
 * The following methods are expected to be implemented by the context data adapter:
 *
 * - Set context data: On initial load, the context data should be set to the initial state.
 * - Get context data: Data loaded from the backend.
 * - Update context data: Called when the context data is updated.
 * - Clear context data: When the app is closed or the user logs out, the context data should be cleared.
 */
interface ContextDataAdapter {
    /**
     * Creates a new context and sets the initial context data when provided.
     * On success, the new context ID should be returned.
     *
     * @param {Object} initialData
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<SetContextResult>}
     */
    create: (initialItems?: ContextItems, extras?: ContextAdapterExtras$1) => Promise<SetContextResult$1>;
    /**
     * Deletes the context data and any registered tasks for the given context ID, and makes the context ID invalid.
     * This method should be used when the context is no longer needed.
     *
     * @param {string} contextId
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    discard: (contextId: string, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Deletes the data for the given context ID and item IDs.
     *
     * @param {string} contextId The context ID.
     * @param {string[]} itemIds The item IDs to delete.
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    removeItems: (contextId: string, itemIds: string[], extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Resets the context data for the given context ID.
     * If no new context data is not provided, the context will be emptied.
     * If new context data is provided, it will replace the existing context data.
     *
     * @param {string} contextId
     * @param {ContextItems} newData
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    resetItems: (contextId: string, newData?: ContextItems, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
    /**
     * Updates data for the given context ID.
     *
     *
     * @param {string} contextId
     * @param {string} itemId
     * @param {Object} data
     * @param {ContextAdapterExtras} extras
     * @returns {Promise<ContextActionResult>}
     */
    updateItems: (contextId: string, itemsToUpdate: Partial<ContextItems>, extras?: ContextAdapterExtras$1) => Promise<ContextActionResult$1>;
}

/**
 * The context adapter context-aware chat experience and AI assistants.
 * This type provides the methods for both context data and tasks that should be implemented by adapters
 * in order to synchronize data related to the context between the frontend and the backend.
 *
 * If your chat experience does not require the execution of tasks, you can use the ContextDataAdapter type instead.
 * But if you need the LLM to execute tasks, as well as access the context data, you should use the ContextAdapter type
 * to implement both the context data and tasks.
 */
interface ContextAdapter extends ContextDataAdapter$1, ContextTasksAdapter$1 {
}

/**
 * This represents the base interface for the context adapter builders.
 * The create method should be implemented to return a new instance of the context adapter.
 * Additional methods can be added to the builder to configure the context adapter via chaining.
 */
interface ContextAdapterBuilder$1 {
    build(): ContextAdapter;
}

declare const predefinedContextSize: {
    '1k': number;
    '10k': number;
    '100k': number;
    '1mb': number;
    '10mb': number;
};
/**
 * Context data synchronization options.
 */
type DataSyncOptions = {
    /**
     * Data synchronization strategy.
     * - `auto` - Batch updates and automatically sync the context data.
     * - `lazy` - Only sync when the user is about to send a message.
     *
     * Default: `auto`
     */
    syncStrategy?: 'auto' | 'lazy';
    /**
     * The maximum size of the context data to be allowed and synced.
     * When the limit is reached, the oldest data will be removed.
     *
     * Default: `10kb`
     */
    contextSize?: number;
};

/**
 * This represents the base interface for the context adapter builders.
 * The create method should be implemented to return a new instance of the context adapter.
 * Additional methods can be added to the builder to configure the context adapter via chaining.
 */
interface ContextAdapterBuilder {
    build(): ContextAdapter;
}

type CallbackArgType = object | string | number | boolean | symbol | null | undefined | void;
type CallbackFunction = (...args: CallbackArgType[]) => CallbackArgType;

/**
 * Once a context state item is registered, a state item handler with this interface will be created.
 * This handler will be used to update the state item's data and to destroy it when it is no longer needed.
 * It can also be used to change the description of the state item.
 */
interface ContextItemHandler$1 {
    /**
     * Once the state item is no longer needed, it should be discarded. This method should be called to destroy the
     * state item. By doing so, the state item will be removed from the context and will no longer be used by the AI.
     */
    discard(): void;
    /**
     * This method is used to update the state item's data. The data is used by the AI to answer context-aware queries.
     * For example, if the user asks the AI about the logged-in user, the AI will use the data to provide the answer.
     * The data should be kept up-to-date to ensure that the AI provides accurate answers.
     *
     * @param {ContextItemDataType} data The new data to be used for the context state item.
     */
    setData(data: ContextItemDataType): void;
    /**
     * When a state item is registered, a description is provided.
     * That description is used by AI to determine how and it what context the state item is used.
     * For example, when the user queries the AI about a specific data in the page, the description will be used to
     * determine which context state items are relevant to the query, and thus it should always be up-to-date.
     *
     * This method can be used to change the description of the state item when the usage of the state item changes.
     * For example, the logged-in user in a marketplace app can be either a buyer or a seller, when they switch from
     * one role to another, the description of the state item should be updated to reflect the new role.
     *
     * @param {string} description
     */
    setDescription(description: string): void;
}
/**
 * Once a context task is registered, a task handler with this interface will be created.
 * This handler will be used to update the task's data, callback, and to destroy it when it is no longer needed.
 * It can also be used to change the description of the task and the descriptions of its parameters.
 */
interface ContextTaskHandler$1 {
    discard(): void;
    setCallback(callback: CallbackFunction): void;
    setDescription(description: string): void;
    setParamDescriptions(paramDescriptions: string[]): void;
}

/**
 * The current status of the context instance.
 * The default status is 'idle' and it changes to 'initializing' when the context is being initialized.
 * A context that is ready to be used has the status 'syncing' (i.e. the being synchronized with the backend).
 * If the context fails to initialize or synchronize, the status changes to 'error'.
 * The final status of a context is 'destroyed' after it has been destroyed.
 */
type AiContextStatus = 'idle' | 'initializing' | 'syncing' | 'error' | 'destroyed';
/**
 * The AiContext is responsible for managing data and tasks in the context of a user session.
 * This data and tasks can be used to provide a more personalized and relevant experience to the AI chatbot user.
 */
interface AiContext {
    /**
     * The unique identifier of the context instance.
     * This identifier is generated by the backend and assigned to the context instance when it is initialized.
     * This is only set once the context has been initialized. It will be null if the context has not been initialized.
     * When the context is destroyed, the context id will be set to null.
     *
     * @returns {string | null}
     */
    get contextId(): string | null;
    /**
     * Destroys the context instance and clears all data and tasks associated with it.
     * The context instance cannot be used after it has been destroyed.
     * If the destroy operation fails, the context instance is left in an error state.
     *
     * @returns {Promise<DestroyContextResult>}
     */
    destroy(): Promise<DestroyContextResult$1>;
    /**
     * Flushes the data synchronization queue.
     * This method will make an API call to the adapter to flush the data synchronization queue.
     * This can be done automatically by the data sync service (the frequency depends on the data sync strategy set),
     * but in situations where the data needs to be flushed immediately, this method can be called.
     *
     * @returns {Promise<FlushContextResult>}
     */
    flush(): Promise<FlushContextResult$1>;
    /**
     * Checks if the context is observing a state item with the provided itemId.
     *
     * @param {string} itemId
     * @returns {boolean}
     */
    hasItem(itemId: string): boolean;
    /**
     * Checks if the context has a task with the provided taskId that can be run.
     * Runnable tasks are tasks that have been registered with the backend and can be executed in the context.
     * When a registration fails, the task is not runnable.
     *
     * @param {string} taskId
     * @returns {boolean}
     */
    hasRunnableTask(taskId: string): boolean;
    /**
     * Checks if the context is observing a task with the provided taskId.
     *
     * @param {string} taskId
     * @returns {boolean}
     */
    hasTask(taskId: string): boolean;
    /**
     * Initializes the context instance and sets the initial data.
     * The context instance cannot be used before it has been initialized.
     * If the initialize operation fails, the context instance is left in an error state.
     * Initialization can only be done once for a context instance, when it's in the 'idle' state.
     *
     * @param {Object} data The optional initial data to set in the context instance.
     * @returns {Promise<InitializeContextResult>}
     */
    initialize(data?: ContextItems): Promise<InitializeContextResult$1>;
    /**
     * Observes a state item and updates the context when the state item's value changes.
     * This method returns a ContextItemHandler that can be used to update the state item's value.
     * If the context instance is destroyed or not properly initialized, the method will return undefined and will
     * log a warning. Users can use the status property to check the status of the context instance.
     *
     * The state item's description passed as a second argument is used by AI to determine how and it what context the
     * state item is used. When the user queries the AI about a specific data in the page, the description will be used
     * to determine which context state items are relevant to the query, and thus it should always be detailed and
     * accurate.
     *
     * @param {string} itemId The unique identifier of the state item to observe.
     * @param {string} description The description of the state item. The description is used to instruct the LLM on
     *      how the state item is used and its role in the context. e.g. When the state item is 'logged-in-user', the
     *      description could be 'The logged-in user in the marketplace app. It can be used to provide a more
     *      personalized experience to the user.'
     *
     * @param {ContextItemDataType} initialData The initial data to set in the state item.
     *
     * @returns {ContextItemHandler | undefined} The state item handler that can be used to update the state item's
     *     value. If the context instance is destroyed or an item with the same itemId is already being observed, the
     *     method will return undefined and a warning will be logged.
     */
    observeState(itemId: string, description: string, initialData?: ContextItemDataType): ContextItemHandler$1 | undefined;
    /**
     * Registers a task in the context instance.
     * A task is a function that can be executed in the context of the user session.
     *
     * @param {string} taskId The unique identifier of the task. If a task with the same identifier already exists,
     *    the registerTask method will return an error.
     * @param {string} description The description of the task. The description is used to instruct the LLM on the
     *  usefulness and role of the task. e.g. When the task is 'get-user-age', the description could be 'Get the age
     *  of the logged-in user from the user profile.'
     * @param {Function} callback The function to execute when the task runs.
     * @param {string[]} paramDescriptions The descriptions of the parameters that the task function expects. The
     *   parameter descriptions are very important because they instruct the LLM on how to retrieve the parameters' data
     *   from the context and how to use them in the task function. The parameter descriptions should be accurate and
     *   explicit. They should describe the role of the parameters in the callback function and how they can be
     *     retrieved. e.g. When the task function expects a parameter that represents the user's preferred language,
     *     the parameter description could be 'The preferred language of the logged-in user. It can be retrieved from
     *     the user profile.'
     *
     * @returns {ContextActionResult}
     */
    registerTask(taskId: string, description: string, callback: CallbackFunction, paramDescriptions?: string[]): ContextTaskHandler$1 | undefined;
    /**
     * Resets the context instance and sets the provided data. The contextId will not change after the reset operation
     * but all the context data and tasks will be cleared.
     * If the reset operation fails, the context instance is left in an error state.
     *
     * The reset operation clears all data and tasks associated with the context instance and sets the provided data.
     * It will also unregister all observers and tasks. You will need to re-register the tasks and re-observe the
     * elements and state items after the reset operation.
     *
     * @param {Object} data The optional data to set in the context instance.
     * @returns {Promise<ContextActionResult>}
     */
    reset(data?: ContextItems): Promise<ContextActionResult$1>;
    /**
     * Runs a task in the context instance.
     *
     * The task runner will attempt to retrieve the parameters from the context and execute the task function.
     * If the task function succeeds, the task runner will return the result of the task function under the 'result'
     * property of the returned object. If the task function fails, the task runner will return an error under the
     * 'error' property of the returned object.
     *
     * The status of the context instance will not change after running a task, regardless of the result of the task
     * function.
     *
     * @param {string} taskId The unique identifier of the task to run.
     * @param {Array<any>} parameters The parameters to pass to the task function.
     * @returns {Promise<RunTaskResult>}
     */
    runTask(taskId: string, parameters?: Array<CallbackArgType>): Promise<RunTaskResult$1>;
    /**
     * Get the status of the context.
     * The status will change as the context is being initialized, destroyed, or if an error occurs.
     *
     * - The initial status is 'idle'.
     * - The status will change to 'initializing' once the context is being initialized.
     * - The status will change to 'syncing' once the context has been initialized and is being synced.
     * - The status will change to 'error' if an error occurs.
     * - The status will change to 'destroyed' once the context has been destroyed.
     *
     * @returns {AiContextStatus}
     */
    get status(): AiContextStatus;
    /**
     * Sets the adapter to use for the context instance.
     * The adapter is responsible for synchronizing the context instance with the backend.
     * This method should be called before the context instance is initialized.
     * If the adapter is not set, the initialize method will fail.
     *
     * @param {ContextAdapterBuilder | ContextAdapter} adapter
     * @returns {AiContext}
     */
    withAdapter(adapter: ContextAdapterBuilder | ContextAdapter): AiContext;
    /**
     * Sets the options to use for data synchronization.
     * The options are used to configure the behavior of the data synchronization process.
     * This method should be called before the context instance is initialized.
     *
     * @param {DataSyncOptions} options
     * @returns {AiContext}
     */
    withDataSyncOptions(options: DataSyncOptions): AiContext;
}

interface ContextDomElementHandler {
    destroy(): void;
}
/**
 * Once a context state item is registered, a state item handler with this interface will be created.
 * This handler will be used to update the state item's data and to destroy it when it is no longer needed.
 * It can also be used to change the description of the state item.
 */
interface ContextItemHandler {
    /**
     * Once the state item is no longer needed, it should be discarded. This method should be called to destroy the
     * state item. By doing so, the state item will be removed from the context and will no longer be used by the AI.
     */
    discard(): void;
    /**
     * This method is used to update the state item's data. The data is used by the AI to answer context-aware queries.
     * For example, if the user asks the AI about the logged-in user, the AI will use the data to provide the answer.
     * The data should be kept up-to-date to ensure that the AI provides accurate answers.
     *
     * @param {ContextItemDataType} data The new data to be used for the context state item.
     */
    setData(data: ContextItemDataType): void;
    /**
     * When a state item is registered, a description is provided.
     * That description is used by AI to determine how and it what context the state item is used.
     * For example, when the user queries the AI about a specific data in the page, the description will be used to
     * determine which context state items are relevant to the query, and thus it should always be up-to-date.
     *
     * This method can be used to change the description of the state item when the usage of the state item changes.
     * For example, the logged-in user in a marketplace app can be either a buyer or a seller, when they switch from
     * one role to another, the description of the state item should be updated to reflect the new role.
     *
     * @param {string} description
     */
    setDescription(description: string): void;
}
/**
 * Once a context task is registered, a task handler with this interface will be created.
 * This handler will be used to update the task's data, callback, and to destroy it when it is no longer needed.
 * It can also be used to change the description of the task and the descriptions of its parameters.
 */
interface ContextTaskHandler {
    discard(): void;
    setCallback(callback: CallbackFunction): void;
    setDescription(description: string): void;
    setParamDescriptions(paramDescriptions: string[]): void;
}

type InitializeContextResult = {
    success: true;
    contextId: string;
} | {
    success: false;
    error: string;
};
type DestroyContextResult = {
    success: true;
} | {
    success: false;
    error: string;
};
type FlushContextResult = {
    success: true;
} | {
    success: false;
    error: string;
};
type RunTaskResult = {
    success: true;
    result?: unknown;
} | {
    success: false;
    error: string;
};
type ContextActionResult = {
    success: true;
} | {
    success: false;
    error: string;
};
type SetContextResult = {
    success: true;
    contextId: string;
} | {
    success: false;
    error: string;
};

declare const createAiContext: () => AiContext;

/**
 * The role of a participant in a conversation.
 *
 * The 'assistant' role is used to represent the AI model responding to the user.
 * The 'system' role is used to represent the system sending messages to the assistant to control its behavior.
 * The 'user' role is used to represent the user sending messages to the assistant.
 */
type ParticipantRole = 'user' | 'system' | 'assistant';

declare const createAiChat: <AiMsg = string>() => AiChat<AiMsg>;

export { AiChat, Observable, createAiChat, createAiContext, predefinedContextSize };
export type { AdapterDecodeFunction, AdapterEncodeFunction, AiChatInternalProps, AiChatProps, AiChatPropsInEvents, AiChatStatus, AiContext, AiContextStatus, AssistAdapter$1 as AssistAdapter, AssistAdapterBuilder, AssistResult$1 as AssistResult, AssistantPersona, BatchSend, ChatAdapter, ChatAdapterBuilder, ChatAdapterExtras, ChatItem, ComposerOptions, ContextActionResult, ContextAdapter$1 as ContextAdapter, ContextAdapterBuilder$1 as ContextAdapterBuilder, ContextAdapterExtras, ContextDataAdapter, ContextDomElementHandler, ContextItem$1 as ContextItem, ContextItemDataType$1 as ContextItemDataType, ContextItemHandler, ContextItems$1 as ContextItems, ContextObject$1 as ContextObject, ContextTask$1 as ContextTask, ContextTaskHandler, ContextTasks$1 as ContextTasks, ContextTasksAdapter, ConversationLayout, ConversationOptions, ConversationStarter, CreateHighlighterOptions, DataSyncOptions, DataTransferMode$1 as DataTransferMode, DestroyContextResult, DisplayOptions, ErrorCallback, ErrorEventDetails, EventCallback, EventName, EventsConfig, EventsMap, FlushContextResult, Highlighter, HighlighterColorMode, HighlighterExtension, HistoryPayloadSize, IObserver, InitializeContextResult, InputFormat, MessageOptions, MessageReceivedCallback, MessageReceivedEventDetails, MessageRenderedCallback, MessageRenderedEventDetails, MessageSentCallback, MessageSentEventDetails, MessageStreamStartedCallback, MessageStreamStartedEventDetails, OutputFormat, ParticipantRole, PersonaOptions, PreDestroyCallback, PreDestroyEventDetails, PromptRenderer, PromptRendererProps, ReadyCallback, ReadyEventDetails, ResponseRenderer, RunTaskResult, SanitizerExtension, SetContextResult, StandardAdapterInfo, StandardChatAdapter, StandardStreamParser, StandardStreamParserOutput, StreamParser, StreamSend, StreamingAdapterObserver$1 as StreamingAdapterObserver, UpdatableAiChatProps, UserPersona };
