!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self)["@nlux/langchain"]={})}(this,function(e){"use strict";var t=Object.defineProperty,r=(e,r,s)=>((e,r,s)=>r in e?t(e,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[r]=s)(e,"symbol"!=typeof r?r+"":r,s);class s extends Error{constructor(e={}){super(e.message),r(this,"exceptionId"),r(this,"message"),r(this,"source"),r(this,"type"),this.message=e.message??"",this.source=e.source,this.type=this.constructor.name,this.exceptionId=e.exceptionId}}class n extends s{}const o=e=>{"string"!=typeof e?e&&"function"==typeof e.toString?console.warn(`[nlux] ${e.toString()}`):console.warn("[nlux]"):console.warn(`[nlux] ${e}`)},a=[],i=e=>{const t=/\/.*\/(invoke|stream)$/g.exec(e);if(!t||t.length<2)return;const r=t[1];return"invoke"===r||"stream"===r?r:void 0},h=e=>{const t=i(e.url),r=e.dataTransferMode,s=t?"stream"===t?"stream":"batch":void 0;const n=s??e.dataTransferMode??f.defaultDataTransferMode;var h;return r&&s&&r!==s&&(h=`The data transfer mode provided to LangServe adapter does not match the LangServe runnable URL action. When you provide a runnable URL that ends with '/${t}', the data transfer mode is automatically set to '${s}' and the 'dataTransferMode' option should not be provided or should be set to '${s}'`,a.includes(h)||(a.push(h),o(h))),n},c=e=>{const t=e.url;return/\/.*\/(invoke|stream)$/g.test(t)?t.replace(/\/(invoke|stream)$/g,""):t},u=e=>{const t=c(e).replace(/\/$/,""),r=(e=>{const t=e.url,r=i(t);return r||("batch"===h(e)?"invoke":"stream")})(e);return`${t}/${r}`};var p=Object.defineProperty,d=(e,t,r)=>((e,t,r)=>t in e?p(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class f{constructor(e){d(this,"__instanceId"),d(this,"__options"),d(this,"theDataTransferModeToUse"),d(this,"theEndpointUrlToUse"),d(this,"theHeadersToUse"),d(this,"theInputSchemaToUse"),d(this,"theInputSchemaUrlToUse"),d(this,"theRunnableNameToUse"),d(this,"theUseInputSchemaOptionToUse"),this.__instanceId=`${this.info.id}-${"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=16*Math.random()|0;return("x"==e?t:3&t|8).toString(16)})}`,this.__options={...e},this.theDataTransferModeToUse=h(e),this.theHeadersToUse=e.headers||{},this.theUseInputSchemaOptionToUse="boolean"!=typeof e.useInputSchema||e.useInputSchema,this.theEndpointUrlToUse=u(e),this.theRunnableNameToUse=(e=>c(e).replace(/\/$/,"").split("/").pop()||"langserve-runnable")(e),this.theInputSchemaUrlToUse=(e=>`${c(e).replace(/\/$/,"")}/input_schema`)(e),this.init()}get dataTransferMode(){return this.theDataTransferModeToUse}get endpointUrl(){return this.theEndpointUrlToUse}get headers(){return this.theHeadersToUse}get id(){return this.__instanceId}get info(){return{id:"langserve-adapter",capabilities:{chat:!0,fileUpload:!1,textToSpeech:!1,speechToText:!1}}}get inputPreProcessor(){return this.__options.inputPreProcessor}get inputSchema(){return this.theInputSchemaToUse}get outputPreProcessor(){return this.__options.outputPreProcessor}get runnableName(){return this.theRunnableNameToUse}get useInputSchema(){return this.theUseInputSchemaOptionToUse}get config(){return this.__options.config}get inputSchemaUrl(){return this.theInputSchemaUrlToUse}async fetchSchema(e){try{const t=await fetch(e),r=await t.json();return"object"==typeof r&&r?r:void o(`LangServe adapter is unable process schema loaded from: ${e}`)}catch(t){return void o(`LangServe adapter is unable to fetch schema from: ${e}`)}}init(){this.useInputSchema&&this.fetchSchema(this.inputSchemaUrl).then(e=>{this.theInputSchemaToUse=e})}preProcessAiBatchedMessage(e,t){if(this.outputPreProcessor)return this.outputPreProcessor(e);if("string"==typeof e)return e;const r=e?.content;if("string"==typeof r)return r;o("LangServe adapter is unable to process the response from the runnable. Returning empty string. You may want to implement an output pre-processor to handle custom responses.")}preProcessAiStreamedChunk(e,t){if(this.outputPreProcessor)return this.outputPreProcessor(e);if("string"==typeof e)return e;const r=e?.content;if("string"==typeof r)return r;o("LangServe adapter is unable to process the chunk from the runnable. Returning empty string. You may want to implement an output pre-processor to handle chunks of custom responses.")}getRequestBody(e,t,r){if(this.inputPreProcessor){const s=this.inputPreProcessor(e,r);return JSON.stringify({input:s,config:t})}if(this.inputSchema){const r=((e,t,r,s)=>{const n=r;if(!n||"object"!=typeof n.properties)return e;if("object"!=typeof n||!n)return o(`LangServer adapter cannot process the input schema fetched for runnable "${s}". The user message will be sent to LangServe endpoint as is without transformations. To override this behavior, you can either set the "useInputSchema" option to false, or provide a custom input pre-processor via the "inputPreProcessor" option, or update your endpoint and input schema to have an object with a single string property or a string as input.`),e;if("string"===n.type)return e;if("object"===n.type){const t="object"==typeof n.properties&&n.properties?n.properties:{},r=Object.keys(t).filter(e=>e&&"string"==typeof t[e].type).map(e=>e);if(1===r.length){const t=r[0];return{[t]:e}}o('LangServer adapter cannot find a valid property to match to user input inside the "${runnableName}" input schema. The user message will be sent to LangServe endpoint as is without transformations. To override this behavior, you can either set the "useInputSchema" option to false, or provide a custom input pre-processor via the "inputPreProcessor" option, or update your endpoint and input schema to have an object with a single string property or a string accepted as part of input schema.')}})(e,0,this.inputSchema,this.runnableName);if(void 0!==r)return JSON.stringify({input:r,config:t})}return JSON.stringify({input:e,config:t})}}d(f,"defaultDataTransferMode","stream");class m extends f{constructor(e){super(e)}async batchText(e,t){const r=this.getRequestBody(e,this.config,t.conversationHistory),s=await fetch(this.endpointUrl,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:r});if(!s.ok)throw new Error(`LangServe runnable returned status code: ${s.status}`);const n=await s.json();if("object"!=typeof n||!n||void 0===n.output)throw new Error('Invalid response from LangServe runnable: Response is not an object or does not contain an "output" property');return"object"==typeof n&&n?n.output:void 0}streamText(e,t,r){throw new n({source:this.constructor.name,message:"Cannot stream text from the batch adapter!"})}}const l=e=>{const t=/^event:\s+(?<event>[\w]+)((\r?)\n(\r?)data: (?<data>(.|\n)*))?/gm.exec(e);if(!t)return;const{event:r,data:s}=t.groups||{};if(r&&("data"===r||"end"===r))try{return{event:r,data:s?JSON.parse(s):void 0}}catch(e){return o(`LangServe stream adapter failed to parse data for chunk event "${r}" | Data: ${s}`),{event:r,data:void 0}}},g=e=>{if(!e)return[];const t=/(((?<=^)|(?<=\n))event:\s+(\w+))/g,r=[];let s=t.exec(e);for(;s;)r.push(s.index),s=t.exec(e);const n=(t,s)=>{const n=r[s+1]||e.length;return e.substring(t,n)};try{return r.map(n).map(l).filter(e=>void 0!==e).map(e=>e)}catch(e){return e instanceof Error?e:[]}},y=e=>{if("object"==typeof e&&null!==e){const t=e;if(t.message&&"string"==typeof t.message&&t.message.toLowerCase().includes("connection error"))return"connection-error"}return null};class b extends f{constructor(e){super(e)}async batchText(e,t){throw new n({source:this.constructor.name,message:"Cannot fetch text using the stream adapter!"})}streamText(e,t,r){const a=this.getRequestBody(e,this.config,r.conversationHistory);fetch(this.endpointUrl,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:a}).then(async e=>{if(!e.ok)throw new s({source:this.constructor.name,message:`LangServe runnable returned status code: ${e.status}`});if(!e.body)throw new s({source:this.constructor.name,message:`LangServe runnable returned status code: ${e.status}`});for await(const r of async function*(e){const t=new TextDecoder("utf-8");let r=e.body.getReader(),{value:s,done:n}=await r.read();s=s?t.decode(s,{stream:!0}):"";let o=/\r?\n\r?\n/g,a=0;for(;;){let e=o.exec(s);if(!e){if(n)break;let e=s.substr(a);({value:s,done:n}=await r.read()),s=e+(s?t.decode(s,{stream:!0}):""),a=o.lastIndex=0;continue}yield s.substring(a,e.index),a=o.lastIndex}a<s.length&&(yield s.substr(a))}(e)){const e=g(r);let s=!1;if(Array.isArray(e))for(const r of e){if("data"===r.event&&void 0!==r.data&&t.next(r.data),"end"===r.event){t.complete(),s=!0;break}await new Promise(e=>setTimeout(e,10))}if(e instanceof Error&&(o(e),t.error(e),s=!0),s)break}}).catch(e=>{o(e),t.error(new n({source:this.constructor.name,message:e.message,exceptionId:y(e)??void 0}))})}}var v=Object.defineProperty,w=(e,t,r)=>((e,t,r)=>t in e?v(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class x{constructor(e){w(this,"theConfig"),w(this,"theDataTransferMode"),w(this,"theHeaders"),w(this,"theInputPreProcessor"),w(this,"theOutputPreProcessor"),w(this,"theUrl"),w(this,"theUseInputSchema"),e&&(this.theDataTransferMode=e.theDataTransferMode,this.theHeaders=e.theHeaders,this.theConfig=e.theConfig,this.theInputPreProcessor=e.theInputPreProcessor,this.theOutputPreProcessor=e.theOutputPreProcessor,this.theUrl=e.theUrl)}create(){if(!this.theUrl)throw new n({source:this.constructor.name,message:"Unable to create LangServe adapter. URL is missing. Make sure you are calling withUrl() before calling create()."});const e={url:this.theUrl,dataTransferMode:this.theDataTransferMode,headers:this.theHeaders,config:this.theConfig,inputPreProcessor:this.theInputPreProcessor,outputPreProcessor:this.theOutputPreProcessor,useInputSchema:this.theUseInputSchema};return"stream"===h(e)?new b(e):new m(e)}withConfig(e){if(void 0!==this.theConfig)throw new n({source:this.constructor.name,message:"Cannot set the config option more than once"});return this.theConfig=e,this}withDataTransferMode(e){if(void 0!==this.theDataTransferMode)throw new n({source:this.constructor.name,message:"Cannot set the data loading mode more than once"});return this.theDataTransferMode=e,this}withHeaders(e){if(void 0!==this.theHeaders)throw new n({source:this.constructor.name,message:"Cannot set the headers option more than once"});return this.theHeaders=e,this}withInputPreProcessor(e){if(void 0!==this.theInputPreProcessor)throw new n({source:this.constructor.name,message:"Cannot set the input pre-processor option more than once"});return this.theInputPreProcessor=e,this}withInputSchema(e){if(void 0!==this.theUseInputSchema)throw new n({source:this.constructor.name,message:"Cannot set the input schema option more than once"});return this.theUseInputSchema=e,this}withOutputPreProcessor(e){if(void 0!==this.theOutputPreProcessor)throw new n({source:this.constructor.name,message:"Cannot set the output pre-processor option more than once"});return this.theOutputPreProcessor=e,this}withUrl(e){if(void 0!==this.theUrl)throw new n({source:this.constructor.name,message:"Cannot set the runnable URL option more than once"});return this.theUrl=e,this}}e.createChatAdapter=()=>new x});
